"use strict";
var body = document.body,
  html = document.documentElement,
  root = document.getElementById("root"),
  vw = window.innerWidth,
  vh = window.innerHeight,
  dh = 0,
  isMobile = vw < 780,
  homeScroll = 0,
  scrollTop = window.scrollY,
  scrollDiff = 0,
  scrollBottom = scrollTop + vh,
  mouse = {
    touchX: 0,
    rawTouchY: 0,
    touchY: 0,
    touchStartX: 0,
    touchStartY: 0,
    touching: !1,
    preventScroll: !1,
    startTime: 0,
    x: 0,
    y: 0,
    down: !1
  },
  resizeQueue = [],
  resizeTimeout = null;

function handleResize() {
  vw = window.innerWidth, vh = window.innerHeight, dh = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight), (!isMobile && vw < 780 || isMobile && 780 <= vw) && (isMobile = vw < 780, positionTiles()), isMobile = vw < 780, clearTimeout(resizeTimeout), resizeTimeout = setTimeout(runResizeQueue, 200)
}

function runResizeQueue() {
  resizeQueue.forEach(function (e) {
    e()
  })
}

function handleScroll() {
  var e = scrollTop;
  scrollTop = window.scrollY, scrollBottom = scrollTop + vh, scrollDiff = scrollTop - e, isMobile ? (mouse.touchX = mouse.touchX, mouse.touchY = mouse.rawTouchY + scrollY + scrollDiff / 10) : mouse.y += scrollDiff, "/" == window.location.pathname && (homeScroll = scrollTop)
}
window.addEventListener("resize", handleResize), document.addEventListener("scroll", handleScroll);
var mouseDisplay = document.getElementById("mouse");

function handleMouse(e) {
  mouse.x = e.clientX, mouse.y = e.clientY + scrollTop
}

function handleTouchStart(e) {
  mouse.touchX = e.touches[0].clientX, mouse.touchY = e.touches[0].clientY + scrollTop, mouse.rawTouchY = e.touches[0].clientY, mouse.touchStartX = mouse.touchX, mouse.touchStartY = mouse.touchY, mouse.touching = !0, mouse.down = !0, mouse.preventScroll = !1, mouse.startTime = Date.now()
}

function handleTouchMove(e) {
  mouse.preventScroll && e.preventDefault(), mouse.touchX = e.touches[0].clientX, mouse.touchY = e.touches[0].clientY + scrollTop, mouse.rawTouchY = e.touches[0].clientY, !mouse.preventScroll && (0 < Math.abs(mouse.touchX - mouse.touchStartX) - Math.abs(mouse.touchY - mouse.touchStartY) / 1.5 || 1e3 < t - mouse.startTime) && (e.preventDefault(), mouse.preventScroll = !0)
}

function handleTouchEnd(e) {
  mouse.touching = !1, mouse.down = !1, mouse.preventScroll = !1
}
var coShowing, hoverElement = null;

function animateTouchMouse(e) {
  if (isMobile && (mouse.x += (mouse.touchX - mouse.x) / Math.max(1, 80 / e), mouse.y += (mouse.touchY - mouse.y) / Math.max(1, 80 / e), "/" == window.location.pathname)) {
    mouseDisplay.style.transform = "translateX(" + mouse.x + "px) translateY(" + mouse.y + "px)";
    var t = hoverElement;
    (hoverElement = document.elementFromPoint(Math.round(mouse.x), Math.round(mouse.y - scrollTop))) != t ? (t && (removeClass(t, "hover"), t.dispatchEvent(new Event("mouseleave")), t.dispatchEvent(new Event("mouseout"))), hoverElement && (addClass(hoverElement, "hover"), hoverElement.dispatchEvent(new Event("mouseenter")), hoverElement.dispatchEvent(new Event("mouseover")), checkHoverCursor(hoverElement))) : hoverElement && hoverElement.dispatchEvent(new Event("mousemove"))
  }
}

function checkHoverCursor(e) {
  removeClass(document.documentElement, "pointer"), removeClass(document.documentElement, "dope");
  for (var t = e, a = !1; t != document.documentElement && t.parentNode;) hasClass(t, "pointer") && addClass(document.documentElement, "pointer"), hasClass(t, "dope") && addClass(document.documentElement, "dope"), hasClass(t, "popup") && (a = !0), t = t.parentNode;
  popups.mouseIn = a
}

function showContactOverlay() {
  var e = Math.max(10, Math.min(isMobile ? .25 * window.innerWidth : .55 * window.innerWidth, mouse.x - .2 * window.innerWidth)),
    t = mouse.y - .075 * window.innerWidth;
  coShowing = !0, new Popup("Contact", e, t, function () {
    var e = document.getElementById("contact-overlay").innerHTML;
    this.scroll.innerHTML = e, this.el.style.width = isMobile ? "28rem" : "36rem", this.el.style.height = isMobile ? "16rem" : "12.5rem", initContactOverlay(this)
  }, function () {
    coShowing = !1
  })
}

function copyLink(e) {
  forEach(document.getElementsByClassName("success"), function (e) {
    removeClass(e, "success")
  });
  var t = e.target.getAttribute("data-copy");
  if (t) {
    var a = document.createElement("input");
    a.style.position = "absolute", a.style.opacity = 0, document.documentElement.append(a), a.value = t, a.select(), document.execCommand("copy"), a.remove(), addClass(e.target, "success")
  }
}

function initContactOverlay(e) {
  var t = e.el.getElementsByClassName("contactOverlay__canvas")[0];
  if (t) {
    initCanvasAndAppend(t, e, t.clientWidth, t.clientHeight);
    var a = e.data;
    a.rows = 14, a.cols = 14, a.grid = [], a.xx = a.cw / a.cols, a.yy = a.ch / a.rows, a.ctx.fillStyle = color.black, initGame(a), window.addEventListener("keydown", handleKeys.bind(a)), t.addEventListener("click", function () {
      a.lost && initGame(a)
    }), e.updateCallback = updateContactOverlay, e.drawCallback = drawContactOverlay
  }
}

function closeContactOverlay() {}

function initGame(t) {
  for (var e = 0; e < t.cols; e++) {
    t.grid[e] = [];
    for (var a = 0; a < t.rows; a++) t.grid[e][a] = 0
  }
  t.sw = .25, t.sm = (1 - t.sw) / 2, t.snake = [[5, 2], [4, 2], [3, 2], [2, 2]], t.startLength = t.snake.length, t.eaten = 0, t.vel = [1, 0], t.speed = 1, t.tick = 250, t.timer = t.tick, t.lost = !1, t.keys = [], t.pressed = !1, forEach(t.snake, function (e) {
    t.grid[e[0]][e[1]] = 2
  }), placeFood(t)
}

function placeFood(e) {
  for (var t, a, n = !1; !n;) t = Math.floor(e.cols * Math.random()), a = Math.floor(e.rows * Math.random()), 0 == e.grid[t][a] && (n = !0);
  e.grid[t][a] = 1
}

function handleKeys(e) {
  coShowing && !this.lost && (38 != e.keyCode && 40 != e.keyCode || e.preventDefault(), this.keys.push(e.keyCode))
}

function updateContactOverlay(e, t, a) {
  if (!t.lost && (t.timer += a * t.speed, t.timer >= t.tick)) {
    if (t.snake.length > 2 * t.eaten + t.startLength) {
      var n = t.snake.pop();
      t.grid[n[0]][n[1]] = 0
    }
    t.corner = 0 == t.vel[0] ? 3 : 2, 0 < t.keys.length && parseKey(t.keys[0], t), 0 != t.corner && (t.grid[t.snake[0][0]][t.snake[0][1]] = t.corner), e.drawRequired = !0, t.timer -= t.tick;
    var o = [(t.snake[0][0] + t.vel[0] + t.cols) % t.cols, (t.snake[0][1] + t.vel[1] + t.rows) % t.rows];
    1 == t.grid[o[0]][o[1]] ? (t.eaten++, t.speed += .04, t.sw = Math.min(.8, t.sw + .01), t.sm = (1 - t.sw) / 2, placeFood(t)) : 0 == t.grid[o[0]][o[1]] || o[0] == t.snake[t.snake.length - 1][0] && o[1] == t.snake[t.snake.length - 1][1] || (t.lost = !0), t.snake.unshift(o), t.piece = 0 == t.vel[0] ? 1 == t.vel[1] ? 8 : 10 : 1 == t.vel[0] ? 11 : 9, t.grid[o[0]][o[1]] = t.piece, 1 < t.keys.length ? t.keys = [t.keys[1]] : t.keys = []
  }
}

function parseKey(e, t) {
  switch (e) {
    case 87:
    case 38:
      0 == t.vel[1] && (-1 == t.vel[0] && (t.corner = 5), 1 == t.vel[0] && (t.corner = 4), t.vel = [0, -1]);
      break;
    case 68:
    case 39:
      0 == t.vel[0] && (-1 == t.vel[1] && (t.corner = 6), 1 == t.vel[1] && (t.corner = 5), t.vel = [1, 0]);
      break;
    case 83:
    case 40:
      0 == t.vel[1] && (-1 == t.vel[0] && (t.corner = 6), 1 == t.vel[0] && (t.corner = 7), t.vel = [0, 1]);
      break;
    case 65:
    case 37:
      0 == t.vel[0] && (-1 == t.vel[1] && (t.corner = 7), 1 == t.vel[1] && (t.corner = 4), t.vel = [-1, 0])
  }
}

function drawContactOverlay(e, t) {
  var a = t.xx,
    n = t.yy,
    o = t.sw,
    i = t.sm;
  t.ctx.clearRect(0, 0, t.cw, t.ch);
  for (var s = 0; s < t.cols; s++)
    for (var r = 0; r < t.rows; r++) {
      var l = s * a,
        c = r * n;
      switch (t.grid[s][r]) {
        case 0:
          break;
        case 1:
          t.ctx.fillRect(l, c, a, n);
          break;
        case 2:
          t.ctx.fillRect(l, c + n * i, a, n * o);
          break;
        case 3:
          t.ctx.fillRect(l + a * i, c, a * o, n);
          break;
        case 4:
          t.ctx.fillRect(l, c + n * i, a * (1 - i), n * o), t.ctx.fillRect(l + a * i, c, a * o, n * (1 - i));
          break;
        case 5:
          t.ctx.fillRect(l + a * i, c + n * i, a * (1 - i), n * o), t.ctx.fillRect(l + a * i, c, a * o, n * (1 - i));
          break;
        case 6:
          t.ctx.fillRect(l + a * i, c + n * i, a * (1 - i), n * o), t.ctx.fillRect(l + a * i, c + n * i, a * o, n * (1 - i));
          break;
        case 7:
          t.ctx.fillRect(l, c + n * i, a * (1 - i), n * o), t.ctx.fillRect(l + a * i, c + n * i, a * o, n * (1 - i));
          break;
        case 8:
          t.ctx.fillRect(l + a * i, c, a * o, n * (1 - i));
          break;
        case 9:
          t.ctx.fillRect(l + a * i, c + n * i, a * (1 - i), n * o);
          break;
        case 10:
          t.ctx.fillRect(l + a * i, c + n * i, a * o, n * (1 - i));
          break;
        case 11:
          t.ctx.fillRect(l, c + n * i, a * (1 - i), n * o)
      }
    }
}

function init() {
  initPageTransitions(), handleResize(), initPage(enterPage)
}

function initPage(e) {
  "/" == window.location.pathname ? (initTiles(e), initPopups()) : "/about" == window.location.pathname ? initPopups() : (initScrollAnimations(), initProjectAnimations(), e())
}
document.addEventListener("mousemove", handleMouse), document.addEventListener("mousedown", function () {
  mouse.down = !0
}), document.addEventListener("mouseup", function () {
  mouse.down = !1
}), body.addEventListener("touchstart", handleTouchStart, {
  passive: !1
}), body.addEventListener("touchmove", handleTouchMove, {
  passive: !1
}), body.addEventListener("touchend", handleTouchEnd, {
  passive: !1
}), window.addEventListener("touchstart", handleTouchStart, {
  passive: !1
}), window.addEventListener("touchmove", handleTouchMove, {
  passive: !1
}), window.addEventListener("touchend", handleTouchEnd, {
  passive: !1
}), document.addEventListener("touchstart", handleTouchStart, {
  passive: !1
}), document.addEventListener("touchmove", handleTouchMove, {
  passive: !1
}), document.addEventListener("touchend", handleTouchEnd, {
  passive: !1
}), html.addEventListener("touchstart", handleTouchStart, {
  passive: !1
}), html.addEventListener("touchmove", handleTouchMove, {
  passive: !1
}), html.addEventListener("touchend", handleTouchEnd, {
  passive: !1
}), "loading" != document.readyState ? init() : document.addEventListener ? document.addEventListener("DOMContentLoaded", init) : document.attachEvent("onreadystatechange", function () {
  "complete" == document.readyState && init()
});
var oldPage, pageContainer = document.getElementById("page-container"),
  newPage = document.getElementsByClassName("page-inner")[0],
  pageExited = !0,
  pageLoaded = !1;

function initPageTransitions() {
  on(".innerLink", "click", handleLinkClick), window.addEventListener("popstate", handlePop), window.history.scrollRestoration = "manual"
}

function handleLinkClick(e) {
  e.preventDefault(), e.stopPropagation();
  var t = e.target.getAttribute("href");
  window.history.pushState({}, "", t), transitionToPage(t), "/" == t && (homeScroll = 0)
}

function transitionToPage(a) {
  pageLoaded = !1, oldPage = newPage, exitPage(), getAjax(a, function (e) {
    var t = (new DOMParser).parseFromString(e, "text/html").getElementsByClassName("page-inner")[0];
    t ? (newPage = t, pageContainer.appendChild(newPage), pageLoaded = !0, pageExited && initPage(enterPage)) : window.location.href = a
  })
}

function enterPage() {
  setTimeout(function () {
    oldPage && oldPage.remove(), "/" == window.location.pathname ? (window.scrollTo(0, homeScroll), mouseDisplay.style.opacity = 1, addClass(document.getElementById("nav"), "home")) : (window.scrollTo(0, 0), tiles = [], removeClass(document.getElementById("nav"), "home")), removeClass(newPage, "exit"), addClass(newPage, "enter"), root = newPage, removeClass(document.documentElement, "no-scroll"), pageExited = !1
  }, 500)
}

function exitPage() {
  addClass(document.documentElement, "no-scroll"), removeClass(oldPage, "enter"), addClass(oldPage, "exit"), closeAllPopups(), setTimeout(function () {
    pageExited = !0, pageLoaded && initPage(enterPage)
  }, 500), "/" == window.location.pathname && handData ? (clearInterval(handData.saveInterval), handSave(), removeClass(document.getElementById("nav"), "home")) : (mouseDisplay.style.opacity = 0, addClass(document.getElementById("nav"), "home")), clearScrollAnimations(), clearProjectAnimations(), addClass(document.getElementById("nav"), "hide"), showingNav = !1
}

function handlePop(e) {
  transitionToPage(window.location)
}
var popups = {
    list: [],
    holding: null,
    prevMouse: {
      x: 0,
      y: 0
    },
    mouseIn: !1
  },
  holdingKnob = null;

function initPopups() {
  on(".showContactOverlay", "click", showContactOverlay);
  for (var e = document.querySelectorAll(".showContactOverlay"), t = 0; t < e.length; t++) e[t].addEventListener("click", showContactOverlay);
  on(".projectLink", "click", showProjectOverlay);
  var a = document.querySelectorAll(".projectLink");
  for (t = 0; t < e.length; t++) a[t].addEventListener("click", showProjectOverlay);
  on(".copyLink", "click", copyLink), window.addEventListener("mousemove", movePopupScroll), window.addEventListener("mouseup", endPopupScrollHold)
}

function updatePopups() {
  for (var e = 0; e < popups.list.length; e++) popups.list[e].updateCallback && popups.list[e].updateCallback(popups.list[e], popups.list[e].data, delta)
}

function drawPopups() {
  for (var e = 0; e < popups.list.length; e++) popups.list[e].drawRequired && popups.list[e].drawCallback && (popups.list[e].drawCallback(popups.list[e], popups.list[e].data), popups.list[e].drawRequired = !1)
}

function Popup(e, t, a, n, o) {
  var i = getPopupIndex({
    title: e
  });
  if (i || 0 === i) return (s = popups.list[i]).offset = {
    x: t,
    y: a
  }, s.el.style.transform = "translate3d(" + t + "px," + a + "px,0)", s.el.style.zIndex = 100 + popups.list.length, s;
  var s = this;
  this.title = e, this.offset = {
    x: t,
    y: a
  }, this.el = createElement("div", "popup"), this.el.style.transform = "translate3d(" + t + "px," + a + "px,0)", this.el.style.zIndex = 100 + popups.list.length, this.el.addEventListener("mousedown", bringPopupToFront.bind(this)), this.el.addEventListener("mouseenter", function () {
    popups.mouseIn = !0, s.active = !0
  }), this.el.addEventListener("mouseleave", function () {
    popups.mouseIn = !1, s.active = !1
  }), this.top = createElement("div", "popup__top", e, this.el), this.top.addEventListener("mousedown", movePopupStart.bind(this)), this.close = createElement("div", "popup__close", null, this.el), o && this.close.addEventListener("click", o.bind(this)), this.close.addEventListener("click", closePopup.bind(this)), this.inner = createElement("div", "popup__inner", null, this.el), this.scroll = createElement("div", "popup__scroll", null, this.inner), this.active = !1, root.append(this.el), this.bounds = this.el.getBoundingClientRect(), this.data = {}, n && n.bind(this)(), this.el.scrollHeight < this.scroll.scrollHeight ? (this.scrollBar = createElement("div", "popup__scrollBar", null, this.inner), this.scrollKnob = createElement("div", "popup__scrollKnob", null, this.scrollBar), this.scroll.addEventListener("scroll", handlePopupScroll.bind(this)), handleScrollBar(this)) : this.el.style.height = isMobile ? this.scroll.scrollHeight + .08 * window.innerWidth + "px" : this.scroll.scrollHeight + .02 * window.innerWidth + "px", popups.list.push(this)
}

function movePopupStart() {
  popups.holding = this, popups.prevMouse.x = mouse.x, popups.prevMouse.y = mouse.y
}

function movePopupMove() {
  if (popups.holding) {
    var e = popups.holding;
    e.offset.x += mouse.x - popups.prevMouse.x, e.offset.y += mouse.y - popups.prevMouse.y, e.el.style.transform = "translate3d(" + e.offset.x + "px," + e.offset.y + "px,0)", popups.prevMouse.x = mouse.x, popups.prevMouse.y = mouse.y
  }
}

function movePopupEnd() {
  popups.holding && (popups.holding = !1)
}

function handlePopupScroll() {
  if (this.scrollBar) {
    var e = this.scroll.scrollTop / (this.scroll.scrollHeight - this.scroll.offsetHeight),
      t = (this.scroll.offsetHeight - this.scrollKnob.offsetHeight) * e;
    this.scrollKnob.style.transform = "translateY(" + t + "px)"
  }
}

function handleScrollBar(t) {
  t.scrollKnob.addEventListener("mousedown", function (e) {
    addClass((holdingKnob = {
      popup: t,
      start: e.clientY,
      offset: t.scroll.scrollTop
    }).popup.scrollKnob, "holding")
  })
}

function movePopupScroll(e) {
  if (null != holdingKnob) {
    var t = e.clientY - holdingKnob.start;
    console.log(t);
    var a = holdingKnob.popup.scroll.scrollHeight / holdingKnob.popup.scroll.offsetHeight;
    holdingKnob.popup.scroll.scrollTo(0, holdingKnob.offset + t * a)
  }
}

function endPopupScrollHold() {
  null != holdingKnob && (removeClass(holdingKnob.popup.scrollKnob, "holding"), holdingKnob = null)
}

function closePopup() {
  var e = getPopupIndex(this);
  this.el.remove(), popups.list.splice(e, 1), popups.mouseIn = !1
}

function closeAllPopups() {
  popups.list.forEach(function (e) {
    closePopup.bind(e)()
  })
}

function getPopupIndex(e) {
  for (var t = 0; t < popups.list.length; t++)
    if (e.title == popups.list[t].title) return t;
  return !1
}

function bringPopupToFront() {
  popups.list.push(popups.list.splice(getPopupIndex(this), 1)[0]), forEach(popups.list, function (e, t) {
    e.el.style.zIndex = 100 + t
  })
}

function showProjectOverlay(e) {
  var t = e.target,
    a = "Project: " + t.getAttribute("data-title"),
    n = (t.getAttribute("data-image"), e.target.parentNode.getElementsByClassName("project__popup")[0].innerHTML);
  new Popup(a, Math.max(10, Math.min(isMobile ? .05 * window.innerWidth : .55 * window.innerWidth, mouse.x - .2 * window.innerWidth)), mouse.y - .1 * window.innerWidth, function () {
    this.scroll.innerHTML = n, this.el.style.width = "36rem", this.el.style.height = isMobile ? "30rem" : "24rem", initProjectOverlay(this)
  }, function () {})
}

function initProjectOverlay(e) {
  e.el.focus();
  var t = e.el.getElementsByClassName("projectOverlay__canvas")[0],
    a = e.el.getElementsByClassName("projectOverlay__video")[0];
  if (t && a) {
    initCanvasAndAppend(t, e, t.clientWidth / 5, t.clientHeight / 5);
    var n = e.data;
    n.video = a, n.ctx.imageSmoothingEnabled = !1, n.backCanvas = document.createElement("canvas"), n.backCtx = n.backCanvas.getContext("2d"), n.backCanvas.width = n.canvas.width, n.backCanvas.height = n.canvas.height, n.noise = new SimplexNoise, e.updateCallback = updateProjectOverlay, e.drawCallback = drawProjectOverlay
  }
}

function updateProjectOverlay(e, t, a) {
  e.active ? (t.video.paused && t.video.play(), e.drawRequired = !0) : t.video.paused || t.video.pause()
}

function drawProjectOverlay(e, t) {
  t.backCtx.drawImage(t.video, -.45 * t.cw, 0, 1.9 * t.cw, t.ch);
  var a = t.backCtx.getImageData(0, 0, t.cw, t.ch);
  messWithPixels(a.data, a.width, a.height, t), t.ctx.putImageData(a, 0, 0)
}

function messWithPixels(e, a, n, o) {
  var i = Math.round(10 * o.noise.noise3D(1, 1, t) - 5) / 10;
  if (mouse.down)
    for (var s = 0; s < e.length / 4; s++) {
      var r = t % (s % 60 + t % 20) / 3 * i,
        l = s % a,
        c = Math.floor(s / a),
        d = Math.round(3 * o.noise.noise3D(l / 100, c / 100, t / 5e3) * r),
        u = Math.round(3 * o.noise.noise3D(l / 100, c / 100 + 1e3, t / 5e3) * r),
        p = Math.max(0, Math.min(a - 1, l + d)),
        h = Math.max(0, Math.min(n - 1, c + u));
      e[4 * s] = e[4 * (h * a + p)], e[4 * s + 1] = e[4 * (h * a + p) + 1], e[4 * s + 2] = e[4 * (h * a + p) + 2]
    }
}
window.addEventListener("mousemove", movePopupMove), window.addEventListener("mouseup", movePopupEnd);
var pels = null,
  pdata = null,
  pupdate = !1,
  showingNav = !1;

function initProjectAnimations() {
  setTimeout(function () {
    pupdate = !0, pels = {
      header: document.getElementById("header"),
      headerImage: document.getElementById("header-image"),
      headerBanner: document.getElementById("header-banner"),
      header: document.getElementById("footer"),
      footer: document.getElementById("footer"),
      footerImage: document.getElementById("footer-image"),
      footerContentInner: document.getElementById("footer-content-inner"),
      footerContentInnerWrap: document.getElementById("footer-content-inner-wrap"),
      footerContentOuter: document.getElementById("footer-content-outer")
    }, pdata = {
      hx: 0,
      hy: 0,
      dir: 0,
      scale: .2,
      targetScale: 1,
      headerHeight: pels.header.getBoundingClientRect().height,
      footerTop: pels.footer.getBoundingClientRect().top + scrollTop,
      fx: 0,
      fy: 0
    }, requestAnimationFrame(drawProjectAnimations)
  }, 700)
}

function drawProjectAnimations() {
  if (pupdate) {
    var e = t;
    t = Date.now(), animateTouchMouse(delta = Math.min(100, t - e));
    var a = pdata.headerHeight > scrollTop,
      n = pdata.footerTop < scrollTop + vh,
      o = mouse.x / vw - .5,
      i = mouse.y / vh - .5,
      s = Math.min(1, Math.max(-1, o * -i));
    if (a) {
      pdata.hx += (o - pdata.hx) / 20 * delta / 16, pdata.hy += (i - pdata.hy) / 20 * delta / 16, pdata.hy = Math.min(pdata.headerHeight, pdata.hy), pdata.dir += (s - pdata.dir) / 30 * delta / 16, pdata.scale += (pdata.targetScale - pdata.scale) / 12 * delta / 16;
      Math.sqrt(Math.pow(o - pdata.hx, 2) + Math.pow(i - pdata.hy, 2));
      var r = "translateX(" + -5 * pdata.hx + "%)",
        l = "translateY(" + 6 * pdata.hy + "%)",
        c = "scaleX(" + (pdata.scale - .15 * Math.abs(pdata.hx)) + ")",
        d = "scaleY(" + (pdata.scale - .15 * Math.abs(pdata.hy)) + ")",
        u = "rotateY(" + -5 * pdata.hx + "deg)",
        p = "rotateX(" + -5 * pdata.hy + "deg)";
      pels.headerImage.style.transform = "perspective(30vw)" + r + l + c + d + u + p, r = "translateX(" + (-5 * pdata.hx - 50) + "%)", l = "translateY(" + (50 * pdata.hy - 50) + "%)";
      var h = "rotate(" + 50 * pdata.dir + "deg)";
      pels.headerBanner.style.transform = r + l + h, forEach(pels.headerBanner.children, function (e, t) {
        var a = "translateX(" + ((pdata.hx + pdata.hy) * (t % 2 == 0 ? 2 : -1) * 10 + (t % 2 == 0 ? 0 : 20)) + "%)",
          n = "translateY(" + (80 * pdata.hy - 30) * (t - 1) + "%)";
        e.style.transform = a + n
      })
    }
    if (n) {
      pdata.fx += (o - pdata.fx) / 20 * delta / 16, pdata.fy += (i - pdata.footerTop / vh - pdata.fy) / 20 * delta / 16, pdata.fy = Math.max(-1, pdata.fy);
      var m = o - pdata.fx,
        v = (pdata.footerTop, pdata.fy, 20 * pdata.fx),
        f = 10 * pdata.fy,
        g = 10 * pdata.fy,
        y = -10 * pdata.fx,
        w = -5 * pdata.fy,
        x = 10 * pdata.fx;
      r = "translateX(" + v + "vw)", l = "translateY(" + f + "vh)", h = "rotate(" + g + "deg)", c = "skew(" + 15 * m + "deg)";
      pels.footerImage.style.transform = r + l + h + c, r = "translateX(" + y + "vw)", l = "translateY(" + w + "vh)", h = "rotate(" + x + "deg)";
      d = "skew(" + 15 * m + "deg)";
      pels.footerContentOuter.style.transform = r + l + h + d, r = "translateX(" + (y - v) + "vw)", l = "translateY(" + (w - f) + "vh)", h = "rotate(" + x + "deg)", pels.footerContentInner.style.transform = r + l + h + d, h = "rotate(" + -g + "deg)";
      c = "skew(" + -15 * m + "deg)";
      pels.footerContentInnerWrap.style.transform = h + c
    }
    0 < scrollTop && !showingNav && (n || scrollDiff < -10) && (removeClass(document.getElementById("nav"), "hide"), showingNav = !0), showingNav && !n && 10 < scrollDiff && (addClass(document.getElementById("nav"), "hide"), showingNav = !1), requestAnimationFrame(drawProjectAnimations)
  }
}

function clearProjectAnimations() {
  pupdate = !1, pdata = pels = null
}
var sasInterval = null;

function initScrollAnimations() {
  var a = document.getElementsByClassName("sa"),
    n = vh - 10 * vw / 100;
  isMobile && (n = .8 * vh), sasInterval = setInterval(function () {
    for (var e = 0; e < a.length; e++) {
      if (isMobile) t = a[e].getAttribute("data-offset") * vh / 80 || 0;
      else var t = a[e].getAttribute("data-offset") * vw / 100 || 0;
      a[e].getBoundingClientRect().top < n + t && (addClass(a[e], "sa-enter"), removeClass(a[e], "sa"), e--)
    }
  }, 100)
}

function clearScrollAnimations() {
  clearInterval(sasInterval)
}
var numberConfig, min1, min2, sec1, sec2, tiles = [],
  t = Date.now(),
  dt = 100,
  delta = 16,
  afr = 0,
  fc = 0,
  dropCount = 0,
  rem = 1 / 16,
  exit = !1,
  dpi = Math.min(2, window.devicePixelRatio) || 1,
  color = {
    red: "#bf645a",
    green: "#3f942e",
    purple: "#74558A",
    yellow: "#fff675",
    grey: "#E8E9DE",
    khaki: "#B3B954",
    black: "#000000",
    white: "#ffffff"
  };

function initTiles(e) {
  createTileData(), positionTiles(), setTimeout(function () {
    initTileData(), animateTiles(), e()
  }, 300), setInterval(assessPerformance, 1e3)
}

function assessPerformance() {
  Math.round(1e3 / afr) < 30 ? dropCount++ : dropCount = Math.max(0, dropCount - 1), 10 < dropCount && 2 == dpi && (dpi = 1, runResizeQueue())
}

function createTileData() {
  forQuery(".tile", function (e) {
    var t = new Tile(e);
    tiles.push(t)
  })
}

function Tile(e) {
  this.el = e, this.col = e.getAttribute("data-col"), this.row = e.getAttribute("data-row"), this.width = e.getAttribute("data-width"), this.height = e.getAttribute("data-height"), this.mcol = e.getAttribute("data-mcol"), this.mrow = e.getAttribute("data-mrow"), this.mwidth = e.getAttribute("data-mwidth"), this.mheight = e.getAttribute("data-mheight");
  var t = e.getElementsByClassName("tile__inner")[0];
  if (t) {
    var a = (this.inner = t).getAttribute("data-action");
    (this.action = a) && (this.initCallback = window["tileInit" + capitalize(a)], this.updateCallback = window["tileUpdate" + capitalize(a)], this.drawCallback = window["tileDraw" + capitalize(a)])
  }
  this.top = 0, this.bottom = 0, this.left = 0, this.right = 0, this.isInView = !1, this.isActive = !1, this.drawRequired = !0, this.updateRequired = !1, this.forceUpdate = !1, this.firstActiveFrame = !1, this.isFirstFrame = !0, this.lastActiveFrame = !1, this.mouse = {
    x: 0,
    y: 0
  }, this.resizeRatio = 1, this.data = {}
}

function positionTiles() {
  forEach(tiles, function (e) {
    e.el.style.gridRow = isMobile ? (e.el.style.gridColumn = e.mcol + " / span " + e.mwidth, e.mrow + " / span " + e.mheight) : (e.el.style.gridColumn = e.col + " / span " + e.width, e.row + " / span " + e.height), setTimeout(function () {
      sizeTile(e)
    }, 100)
  }), resizeQueue.push(resizeTiles)
}

function sizeTile(e) {
  var t = document.getElementById("tile-container").getBoundingClientRect().top + scrollTop,
    a = e.el.getBoundingClientRect();
  a = {
    width: a.width,
    height: a.height,
    top: a.top - t,
    left: a.left
  }, e.bounds = a, e.top = a.top + scrollTop, e.bottom = a.top + a.height + scrollTop, e.left = a.left, e.right = a.left + a.width
}

function resizeTiles() {
  forEach(tiles, sizeTile)
}

function initTileData() {
  forEach(tiles, function (e) {
    e.initCallback && e.initCallback(e)
  })
}

function animateTiles() {
  var e = t;
  t = Date.now(), delta = Math.min(100, t - e), afr = (afr * fc + delta) / (fc + 1), fc++, animateTouchMouse(delta), exit ? handleProjectScroll() : (updateTiles(), drawTiles(), updatePopups(), drawPopups()), 0 < tiles.length && requestAnimationFrame(animateTiles)
}

function updateTiles() {
  forEach(tiles, function (e) {
    if (e.isInView = e.bottom > scrollTop - 100 && e.top < scrollBottom + 100 || e.forceUpdate, e.isInView || !e.lastActiveFrame || e.updateRequired) {
      var t = e.isActive;
      e.isActive = !popups.mouseIn && mouse.y > e.top && mouse.y < e.bottom && mouse.x > e.left && mouse.x < e.right, e.firstActiveFrame = e.isActive && !t, e.lastActiveFrame = !e.isInView && !e.firstActiveFrame, e.updateCallback && e.updateCallback(e, e.data, delta)
    }
  })
}

function drawTiles() {
  forEach(tiles, function (e) {
    e.isInView && e.drawRequired && e.drawCallback && (e.drawCallback(e, e.data), e.drawRequired = !1), e.isInView && (e.isFirstFrame = !1)
  })
}

function initCanvasAndAppend(e, t, a) {
  t.data.canvas = e, t.data.ctx = e.getContext("2d"), sizeCanvas(t, a), resizeQueue.push(resizeCanvas.bind([t, a]))
}

function sizeCanvas(e, t) {
  if (t) a = e.data.canvas.clientWidth, n = e.data.canvas.clientHeight;
  else var a = e.bounds.width,
    n = e.bounds.height;
  e.data.cw = e.data.canvas.width = a * dpi, e.data.ch = e.data.canvas.height = n * dpi, e.data.canvas.style.width = a + "px", e.data.canvas.style.height = n + "px", e.data.dpi = dpi
}

function resizeCanvas() {
  var e = this[0],
    t = this[1],
    a = e.data.cw;
  sizeCanvas(e, t);
  var n = e.data.cw;
  e.resizeRatio = n / a, e.drawRequired = !0
}

function updateTileMouseRelative(e, t, a) {
  a && (t = 16 * t / a), e.mouse.x += ((mouse.x - e.left) / e.bounds.width - .5 - e.mouse.x) / t, e.mouse.y += ((mouse.y - e.top) / e.bounds.height - .5 - e.mouse.y) / t
}

function updateTileMousePixels(e, t, a) {
  a && (t = 16 * t / a), e.mouse.x += (mouse.x - e.left - e.mouse.x) / t, e.mouse.y += (mouse.y - e.top - e.mouse.y) / t
}

function hasClass(e, t) {
  return e.classList ? e.classList.contains(t) : new RegExp("\\b" + t + "\\b").test(e.className)
}

function addClass(e, t) {
  e.classList ? e.classList.add(t) : hasClass(e, t) || (e.className += " " + t)
}

function removeClass(e, t) {
  e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("\\b" + t + "\\b", "g"), "")
}

function toggleClass(e, t) {
  hasClass(e, t) ? removeClass(e, t) : addClass(e, t)
}

function boolClass(e, t, a) {
  a && !hasClass(e, t) ? addClass(e, t) : !a && hasClass(e, t) && removeClass(e, t)
}

function on(n, e, o, i) {
  addEvent(i || document, e, function (e) {
    for (var t, a = e.target || e.srcElement; a && a.matches && a !== i && !(t = a.matches(n));) a = a.parentElement;
    t && o.call(a, e)
  })
}

function addEvent(e, t, a) {
  e.attachEvent ? e.attachEvent("on" + t, a) : e.addEventListener(t, a)
}

function removeEvent(e, t, a) {
  e.detachEvent ? e.detachEvent("on" + t, a) : e.removeEventListener(t, a)
}

function forEach(e, t) {
  for (var a = 0, n = e.length; a < n; a++) t(e[a], a)
}

function forQuery(e, t, a) {
  for (var n = (a = a || document).querySelectorAll(e), o = 0, i = n.length; o < i; o++) t(n[o], o)
}

function sign(e) {
  return 0 != e ? Math.abs(e) / e : e
}

function absFloor(e) {
  return 0 < e ? Math.floor(e) : Math.ceil(e)
}

function clamp(e, t, a) {
  return Math.max(t, Math.min(a, e))
}

function mod(e, t) {
  return e - Math.floor(e / t) * t
}

function getAjax(e, t) {
  var a = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP");
  return a.open("GET", e), a.onreadystatechange = function () {
    3 < a.readyState && 200 == a.status && t(a.responseText)
  }, a.setRequestHeader("X-Requested-With", "XMLHttpRequest"), a.send(), a
}

function postAjax(e, t, a) {
  var n = "string" == typeof t ? t : Object.keys(t).map(function (e) {
      return encodeURIComponent(e) + "=" + encodeURIComponent(t[e])
    }).join("&"),
    o = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP");
  return o.open("POST", e), o.onreadystatechange = function () {
    3 < o.readyState && 200 == o.status && a(o.responseText)
  }, o.setRequestHeader("X-Requested-With", "XMLHttpRequest"), o.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), o.send(n), o
}

function capitalize(e) {
  return e[0].toUpperCase() + e.slice(1)
}

function getVectorDist(e, t, a, n) {
  return Math.sqrt((e - a) * (e - a) + (t - n) * (t - n))
}

function getAngle(e, t) {
  var a = 180 * Math.atan2(t, e) / Math.PI;
  return (360 + Math.round(a)) % 360
}

function arrayRemove(e, t) {
  t.splice(t.indexOf(e), 0)
}

function arrayRandom(e) {
  return e[Math.floor(Math.random() * e.length)]
}

function createElement(e, t, a, n) {
  var o = document.createElement(e);
  return t && (o.classList = t), a && (o.innerHTML = a), n && n.append(o), o
}

function tileInitAbout(e) {
  e.el.addEventListener("click", showAboutPopup), e.data = {
    speed: 1,
    rot: 0,
    lines: document.getElementById("about-lines")
  }
}

function tileUpdateAbout(e, t, a) {
  (e.isActive || .05 < Math.abs(t.speed)) && (e.isActive ? updateTileMouseRelative(e, 2, a) : e.mouse.y = 0, t.speed -= 1 * e.mouse.y, t.speed *= 1 + Math.abs(e.mouse.y) / 9, t.speed *= .94, t.rot += t.speed * a / 16 * .1, e.isInView && (e.drawRequired = !0))
}

function tileDrawAbout(e, t) {
  t.lines.style.transform = "translateZ(-10.5rem) rotateX(" + t.rot + "deg)"
}

function showAboutPopup(e) {
  var t = Math.max(10, Math.min(isMobile ? .05 * window.innerWidth : .55 * window.innerWidth, mouse.x - .2 * window.innerWidth)),
    a = mouse.y - .1 * window.innerWidth,
    n = document.getElementById("about-popup").innerHTML;
  new Popup("About", t, a, function () {
    this.scroll.innerHTML = n, this.el.style.width = "36rem", this.el.style.height = isMobile ? "19rem" : "18rem"
  })
}

function tileInitAngular(e) {
  e.data = {
    angle: 30,
    outputAngle: 30,
    diff: 0,
    dist: 0,
    parts: 8,
    mouse: {
      x: 0,
      y: 0
    }
  }, tileResizeAngular.bind(e)(), resizeQueue.push(tileResizeAngular.bind(e)), initCanvasAndAppend(document.getElementById("angular-canvas"), e), e.el.addEventListener("click", function () {
    e.data.parts++
  })
}

function tileResizeAngular() {
  this.data.left = this.left, this.data.top = this.top, this.data.bounds = this.bounds
}

function tileUpdateAngular(e, t, a) {
  if (e.isActive || e.isFirstFrame) {
    updateTileMouseRelative(e, 30), updateTileMouseRelative(t, 10);
    var n = getAngle(t.mouse.x, t.mouse.y) + 180;
    n < 0 && (n += 360), 360 < n && (n -= 360), t.dist = getVectorDist(0, 0, e.mouse.x, e.mouse.y), t.diff = shortAngleDist(t.outputAngle, n), t.angle += t.diff / (10 + t.parts), t.outputAngle = t.angle % 360, e.drawRequired = !0
  }
}

function shortAngleDist(e, t) {
  var a = (t - e) % 360;
  return 2 * a % 360 - a
}

function tileDrawAngular(e, t) {
  var a = t.cw / 2 + e.mouse.x * t.cw / 2,
    n = t.ch / 2 + e.mouse.y * t.ch / 2,
    o = t.cw / 2,
    i = t.outputAngle * Math.PI / 180;
  t.diff, Math.PI;
  t.ctx.lineWidth = 2 * o;
  for (var s = 0; s < t.parts; s++) {
    var r = 2 * Math.PI * s / t.parts - .01 + i,
      l = 2 * Math.PI * (s + 1) / t.parts + .01 + i;
    l -= (l - r) * Math.abs(t.diff) / 360;
    var c = a + Math.cos(r) * o / (1 + Math.abs(t.diff) / 180),
      d = a + Math.cos(l) * o / (1 + Math.abs(t.diff) / 180),
      u = n + Math.sin(r) * o / (1 + Math.abs(t.diff) / 120),
      p = n + Math.sin(l) * o / (1 + Math.abs(t.diff) / 120);
    lerpColor(color.black, color.white, s / t.parts), lerpColor(color.white, color.black, (s + 1) / t.parts);
    t.gradient = t.ctx.createLinearGradient(c, u, d, p), t.gradient.addColorStop(0, color.black), t.gradient.addColorStop(1, color.white), t.ctx.strokeStyle = t.gradient, t.ctx.beginPath(), t.ctx.arc(a, n, o, r, l), t.ctx.stroke()
  }
}

function tileInitAusjpn(e) {
  initCanvasAndAppend(document.getElementById("ausjpn-canvas"), e), e.data.res = 3 * e.data.dpi, e.data.rows = Math.ceil(e.data.ch / e.data.res), e.data.cols = Math.ceil(e.data.cw / e.data.res), e.data.next = [];
  for (var t = 0; t < e.data.rows; t++) {
    e.data.next[t] = [];
    for (var a = 0; a < e.data.cols; a++) e.data.next[t][a] = 0
  }
  e.data.spawn = 0, e.data.spawnY = 0, e.data.spawnYVar = Math.floor(e.data.rows / 5), e.data.spawnXVar = Math.floor(e.data.cols / 3), document.getElementById("jpn").addEventListener("mouseenter", function () {
    e.data.spawn = -1, e.data.spawnRow = Math.floor(3 * e.data.rows / 4)
  }), document.getElementById("jpn").addEventListener("mouseleave", function () {
    e.data.spawn = 0
  }), document.getElementById("aus").addEventListener("mouseenter", function () {
    e.data.spawn = 1, e.data.spawnRow = Math.ceil(1 * e.data.rows / 4)
  }), document.getElementById("aus").addEventListener("mouseleave", function () {
    e.data.spawn = 0
  }), e.data.stepTime = 150, e.data.wait = 0, e.data.noise = new SimplexNoise, e.data.t = 0, resizeQueue.push(tileResizeAusjpn.bind(e))
}

function tileResizeAusjpn() {
  this.data.res *= this.resizeRatio
}

function tileUpdateAusjpn(e, t, a) {
  if (e.isActive && (t.wait -= a, t.t += a, t.wait < 0)) {
    t.wait += t.stepTime, t.grid = e.data.next, t.next = [];
    for (var n = 0; n < e.data.rows; n++) {
      t.next[n] = [];
      for (var o = 0; o < e.data.cols; o++) t.next[n][o] = getNext(t.grid, n, o, t.rows, t.cols, t.spawn, t.noise, t.t)
    }
    if (0 != e.data.spawn) {
      var i = e.data.spawnRow + Math.round(Math.random() * t.spawnYVar),
        s = Math.round(e.data.cols / 2 + Math.random() * t.spawnXVar);
      t.next[i][s] = e.data.spawn
    }
    e.drawRequired = !0
  }
}

function tileDrawAusjpn(e, t, a) {
  for (var n = 0; n < e.data.rows; n++)
    for (var o = 0; o < e.data.cols; o++) switch (e.data.next[n][o]) {
      case 0:
        t.ctx.clearRect(o * t.res, n * t.res, t.res, t.res);
        break;
      case 1:
        t.ctx.fillStyle = isMobile ? color.green : color.purple, t.ctx.fillRect(o * t.res, n * t.res, t.res, t.res);
        break;
      case -1:
        t.ctx.fillStyle = color.red, t.ctx.fillRect(o * t.res, n * t.res, t.res, t.res)
    }
}

function getNext(e, t, a, n, o, i, s, r) {
  var l = e[t][a],
    c = l * s.noise3D(t / 10, a / 10, r / 1e3) * (mouse.down ? 0 : 2),
    d = (mouse.down ? 20 : 8) * Math.abs(s.noise3D(t / 30, a / 30, r / 1e3));
  return 0 < t && (c += e[t - 1][a] == i ? i * d : e[t - 1][a]), 1 < t && (c += e[t - 2][a] == i ? i * d : e[t - 2][a]), t < n - 1 && (c += e[t + 1][a] == i ? i * d : e[t + 1][a]), t < n - 2 && (c += e[t + 2][a] == i ? i * d : e[t + 2][a]), 0 < a && (c += e[t][a - 1] == i ? i * d : e[t][a - 1]), a < o - 1 && (c += e[t][a + 1] == i ? i * d : e[t][a + 1]), 20 < Math.abs(c) && l != i ? c = i : 0 != c && (c = Math.abs(c) / c), c
}

function tileInitBounce(e) {
  var t = document.getElementById("bounce-canvas");
  e.data = {
    noise: new SimplexNoise,
    update: !1,
    maxSpeed: 10,
    started: !1
  }, initCanvasAndAppend(t, e), tileResizeBounce.bind(e)(), resizeQueue.push(tileResizeBounce.bind(e))
}

function tileResizeBounce() {
  var e = this;
  e.data.baseRad = .1 * e.data.cw, e.data.rad = e.data.baseRad, e.data.toRad = e.data.baseRad, e.mouse = {
    x: e.data.cw / 2 / e.data.dpi,
    y: e.data.ch / 2 / e.data.dpi
  }, e.data.ctx.lineWidth = 2.5 * e.data.dpi / 2, e.data.ctx.strokeStyle = color.yellow, e.data.ctx.fillStyle = color.red
}

function tileUpdateBounce(e, a, n) {
  e.data.started && (e.data.update = e.mouse.x > -a.rad && e.mouse.x < a.cw / 2 + a.rad && e.mouse.y > -a.rad && e.mouse.y < a.ch / 2 + a.rad), e.isActive ? (updateTileMousePixels(e, isMobile ? 30 : 60), e.data.started = !0, e.drawRequired = !0) : e.data.update && (updateTileMousePixels(e, isMobile ? 30 : 60), e.mouse.x += a.noise.noise2D(e.mouse.x / 100, t / 2e3), e.mouse.y += a.noise.noise2D(e.mouse.y / 100, t / 2e3), e.drawRequired = !0), mouse.down ? (a.toRad = (a.noise.noise3D(e.mouse.x / 300, e.mouse.y / 300, t / 5e3) + 1) / 1.5 * a.baseRad, a.rad += .3 * (a.toRad - a.rad)) : (a.toRad = a.baseRad, a.rad += .1 * (a.toRad - a.rad))
}

function tileDrawBounce(e, t) {
  t.ctx.beginPath(), t.ctx.arc(e.mouse.x * t.dpi, e.mouse.y * t.dpi, t.rad, 0, 2 * Math.PI), t.ctx.stroke(), t.ctx.fill()
}

function tileInitBrowser(e) {
  e.data = {
    browser: document.getElementById("browser"),
    x: document.getElementById("browser-x"),
    y: document.getElementById("browser-y"),
    s: document.getElementById("browser-s"),
    c: document.getElementById("browser-c"),
    clicks: 0
  }, on("html", "click", function () {
    e.data.clicks++
  })
}

function tileUpdateBrowser(e, t, a) {
  updateTileMousePixels(e, 1), e.drawRequired = !0
}

function tileDrawBrowser(e, t) {
  t.x.innerHTML = Math.floor(e.mouse.x), t.y.innerHTML = Math.floor(e.mouse.y), t.s.innerHTML = scrollTop, t.c.innerHTML = t.clicks
}

function tileInitCalc(e) {
  e.t = document.getElementById("calc-top"), e.b = document.getElementById("calc-bottom"), e.a = document.getElementById("calc-action"), e.el.addEventListener("click", calculate.bind(e)), e.actions = ["—", "+", "÷", "×"]
}

function calculate() {
  var e = this,
    t = parseInt(e.t.innerHTML),
    a = parseInt(e.b.innerHTML),
    n = 0;
  switch (e.a.innerHTML) {
    case "—":
      n = t - a;
      break;
    case "+":
      n = t + a;
      break;
    case "÷":
      n = t / a;
      break;
    case "×":
      n = t * a
  }
  n %= 100, (n = Math.abs(Math.round(n))) || (n = 0), e.t.innerHTML = addZero(n), e.b.innerHTML = addZero(Math.round(99 * Math.random() + 1)), e.a.innerHTML = arrayRandom(e.actions)
}

function addZero(e) {
  return 1 == String(e).length ? "0" + String(e) : String(e)
}

function tileInitClock(e) {
  min1 = document.getElementById("clock-minute1"), min2 = document.getElementById("clock-minute2"), sec1 = document.getElementById("clock-second1"), sec2 = document.getElementById("clock-second2"), numberConfig = [[1, 2, 0, 0, 4, 3], [1, 0, 9, 0, 9, 0], [1, 2, 1, 3, 0, 0], [4, 2, 8, 0, 1, 3], [2, 1, 4, 0, 9, 0], [0, 0, 4, 2, 4, 3], [1, 3, 0, 2, 4, 3], [4, 0, 1, 3, 0, 9], [3, 4, 6, 8, 2, 1], [1, 2, 4, 0, 9, 3]];
  var t = updateTime.bind(e);
  t(), setInterval(t, 1e3), on(".clock__part", "click", changePart), on(".clock__part", "touchend", changePart)
}

function updateTime() {
  if (this.isInView || this.isFirstFrame) {
    var e = new Date,
      t = String(e.getMinutes());
    t = 2 == t.length ? t : "0" + t;
    var a = String(e.getSeconds());
    a = 2 == a.length ? a : "0" + a, updateNumber(min1, t[0]), updateNumber(min2, t[1]), updateNumber(sec1, a[0]), updateNumber(sec2, a[1])
  }
}

function updateNumber(e, n) {
  hasClass(e, "nm" + n) || (e.className = "clock__number nm" + n, forEach(e.children, function (e, t) {
    var a = numberConfig[n][t];
    e.className = "clock__part cp" + a, e.setAttribute("data-cp", a)
  }))
}

function changePart(e) {
  var t = Math.floor(10 * Math.random()),
    a = e.target.getAttribute("data-cp");
  e.target.className = t == a ? "clock__part cp" + t : "clock__part clock__part--edit cp" + t
}

function tileInitCopy(e) {
  e.data = {
    copy: document.getElementById("copy"),
    angle: 360 * Math.random(),
    pos: {
      x: .5,
      y: .5
    },
    speed: .01,
    minSpeed: .01,
    colors: [color.black, color.green, color.purple, color.khaki, color.yellow, color.red, color.white],
    colorIndex: 0
  };
  var t = e.data.copy.getBoundingClientRect();
  e.data.cw = .96 * t.width, e.data.ch = .8 * t.height, (e.data.angle % 90 < 15 || 85 < e.data.angle % 90) && (e.data.angle += 45)
}

function tileUpdateCopy(e, t, a) {
  if (e.isActive) {
    mouse.down ? t.speed = Math.min(.2, t.speed + .001) : t.speed += (t.minSpeed - t.speed) / 100;
    var n = Math.cos(t.angle / 180 * Math.PI),
      o = Math.sin(t.angle / 180 * Math.PI);
    t.pos.x += t.speed * n, t.pos.y += t.speed * o, t.pos.x * e.bounds.width - t.cw / 2 <= -2 && (updateCopyColor(t), e.data.angle = getAngle(Math.abs(n + .1), o)), t.pos.x * e.bounds.width + t.cw / 2 >= e.bounds.width + 2 && (updateCopyColor(t), e.data.angle = getAngle(-Math.abs(n - .1), o)), t.pos.y * e.bounds.height - t.ch / 2 <= 0 && (updateCopyColor(t), e.data.angle = getAngle(n, Math.abs(o + .1))), t.pos.y * e.bounds.height + t.ch / 2 >= e.bounds.height - 5 && (updateCopyColor(t), e.data.angle = getAngle(n, -Math.abs(o - .1))), e.drawRequired = !0
  }
}

function updateCopyColor(e) {
  e.colorIndex++, e.colorIndex >= e.colors.length && (e.colorIndex = 0), e.copy.style.color = e.colors[e.colorIndex]
}

function tileDrawCopy(e, t) {
  (e.isActive || e.isFirstFrame) && (t.copy.style.transform = "translate3d(" + (t.pos.x * e.bounds.width - t.cw / 2) + "px, " + (t.pos.y * e.bounds.height - t.ch / 2) + "px, 0)")
}

function tileInitDiagonal(e) {
  var t = document.getElementById("diagonal-canvas");
  e.data = {
    lines: 20,
    lineWidth: 2,
    balls: [],
    inLine: -1,
    ballAcc: .1,
    dir: 1,
    colors: [color.red, color.green, color.orange, color.purple, color.khaki, color.yellow]
  }, initCanvasAndAppend(t, e), tileResizeDiagonal.bind(e)(), resizeQueue.push(tileResizeDiagonal.bind(e)), t.addEventListener("click", function () {
    e.data.dir *= -1
  })
}

function tileResizeDiagonal() {
  this.data.rad = this.data.ch / this.data.lines, this.data.aspect = this.data.cw / this.data.ch, this.data.dist = this.data.cw
}

function Ball(e, t, a, n, o) {
  this.p = 1 == n ? -t : o + t, this.v = 0, this.x = 0, this.y = 0, this.line = e, this.color = a
}

function tileUpdateDiagonal(e, t, a) {
  if (e.isActive || e.isFirstFrame || 0 < t.balls.length) {
    updateTileMouseRelative(e, 1);
    var n = Math.floor((e.mouse.x - e.mouse.y + 1) * (t.lines - 1) / 2);
    t.inLine != n && e.isActive && t.balls.push(new Ball(n, t.rad, arrayRandom(t.colors), t.dir, t.dist)), t.inLine = n;
    for (var o = t.balls.length, i = 0; i < o; i++) {
      var s = t.balls[i];
      s.v += t.ballAcc * t.dir * t.dpi / 2, s.p += s.v * a / 16, s.x = s.line * (t.cw / (t.lines - 2) * 2) - t.cw + s.p, s.y = s.p, (1 == t.dir ? s.p > t.dist + 2 * t.rad : s.p < 2 * -t.rad) && (t.balls.splice(i, 1), i--, o--)
    }
    e.drawRequired = !0
  }
}

function tileDrawDiagonal(e, t) {
  t.ctx.clearRect(0, 0, t.cw, t.ch), e.data.ctx.lineWidth = t.lineWidth * t.dpi / 2, e.data.ctx.strokeStyle = color.black;
  for (var a = 0; a < t.lines; a++) t.ctx.beginPath(), t.ctx.moveTo(a * (t.cw / (t.lines - 1) * 2) - t.cw, 0), t.ctx.lineTo(a * (t.cw / (t.lines - 1) * 2), t.ch), t.ctx.stroke();
  for (var n = t.balls.length - 1; 0 <= n; n--) {
    var o = t.balls[n];
    e.data.ctx.fillStyle = o.color, t.ctx.beginPath(), t.ctx.arc(o.x, o.y, t.rad, 0, 2 * Math.PI), t.ctx.fill(), t.ctx.stroke()
  }
}

function tileInitEye(e) {
  e.data = {
    eye: document.getElementById("eye"),
    inner: document.getElementById("eye-inner"),
    dist: 0,
    multi: 0,
    pupils: 4,
    currentPupil: 0
  }, e.data.eye.addEventListener("click", function () {
    hasClass(e.data.eye, "blink") || (addClass(e.data.eye, "blink"), setTimeout(function () {
      e.data.currentPupil++, e.data.currentPupil > e.data.pupils && (e.data.currentPupil = 0), e.data.inner.className = "eye__pupil eye__pupil--" + e.data.currentPupil, removeClass(e.data.eye, "blink"), e.data.targetScale = 1
    }, 400))
  }), setInterval(function () {
    hasClass(e.data.eye, "blink") || (addClass(e.data.eye, "blink"), setTimeout(function () {
      removeClass(e.data.eye, "blink")
    }, 400))
  }, 5e3)
}

function tileUpdateEye(e, t, a) {
  e.isActive ? (updateTileMouseRelative(e, 20, a), t.scale += (t.targetScale - t.scale) / 4) : (e.mouse.x *= .8, e.mouse.y *= .8), .001 < t.dist | e.isActive && (t.dist = getVectorDist(0, 0, e.mouse.x, e.mouse.y), t.multi = 3 / Math.pow(t.dist, .5), e.drawRequired = !0)
}

function tileDrawEye(e, t) {
  .001 < t.dist && (t.eye.style.transform = "translate3d(" + e.mouse.x * t.multi + "rem, " + e.mouse.y * t.multi + "rem, 0)", t.inner.style.transform = "translate3d(" + 5 * e.mouse.x + "rem, " + 2 * e.mouse.y + "rem, 0)")
}

function tileInitFooter(e) {
  e.el.getElementsByClassName("footer__lu")[0].addEventListener("click", toggleLu), e.el.getElementsByClassName("footer__ra")[0].addEventListener("click", toggleRa)
}

function toggleLu() {
  var e = document.getElementById("adjust");
  "rgb(250, 250, 250)" != e.style.background ? (e.style.background = "#fafafa", e.style.mixBlendMode = "exclusion", removeClass(e, "rotate")) : (e.style.background = "", e.style.mixBlendMode = "")
}

function toggleRa() {
  var e = document.getElementById("adjust");
  console.log(e.style.background), hasClass(e, "rotate") ? (e.style.background = "", e.style.mixBlendMode = "", removeClass(e, "rotate")) : (e.style.background = "#ffd900", addClass(e, "rotate"))
}

function tileInitGreyGrad(e) {
  var t = document.getElementById("greygrad-canvas");
  e.data = {
    mouse: {
      x: 0,
      y: 0
    },
    rings: [],
    ringSpeed: 30,
    ringSpace: .01,
    addRing: !0
  }, initCanvasAndAppend(t, e), tileResizeGreyGrad.bind(e)(), resizeQueue.push(tileResizeGreyGrad.bind(e)), e.mouse = {
    x: e.data.cw / 2 / e.data.dpi,
    y: e.data.ch / 2 / e.data.dpi
  }, e.data.mouse = {
    x: e.data.cw / 2 / e.data.dpi,
    y: e.data.ch / 2 / e.data.dpi
  }, e.mouse = {
    x: -.117,
    y: -.154
  }, e.data.mouse = {
    x: -.117,
    y: -.154
  }
}

function tileResizeGreyGrad() {
  this.data.left = this.left, this.data.top = this.top, this.data.bounds = this.bounds, this.updateRequired = !0
}

function tileUpdateGreyGrad(e, t, a) {
  if (e.isActive || e.isFirstFrame || e.updateRequired) {
    e.isActive && (updateTileMouseRelative(e, 20, a), updateTileMouseRelative(t, 120, a));
    var n = e.data.cw / 2,
      o = t.cw / 2 - n * t.mouse.x,
      i = t.ch / 2 - t.ch / 2 * t.mouse.y,
      s = n,
      r = t.cw / 2 + n * e.mouse.x * 2,
      l = t.ch / 2 + t.ch / 2 * e.mouse.y * 2;
    mouse.down ? t.addRing && (t.rings.push([1]), t.addRing = !1) : t.addRing = !0;
    var c = t.ctx.createRadialGradient(o, i, s, r, l, 0);
    c.addColorStop(0, color.white);
    for (var d = 0; d < t.rings.length; d++) .001 < t.rings[d] ? (c.addColorStop(t.rings[d], color.white), c.addColorStop(t.rings[d] - Math.max(1e-6, t.ringSpace * t.rings[d] - .001), color.black), t.rings[d] -= t.rings[d] / t.ringSpeed) : t.rings.splice(d, 1);
    c.addColorStop(1, color.black), t.grd = c, e.drawRequired = !0, e.updateRequired = !1
  }
}

function tileDrawGreyGrad(e, t) {
  t.ctx.clearRect(0, 0, t.cw, t.ch), t.ctx.fillStyle = t.grd, t.ctx.fillRect(0, 0, t.cw, t.ch)
}

function tileInitIntro(e) {
  var a = ["class", "t-red", "t-green", "t-purple", "t-yellow", "t-black"];
  forEach(document.getElementById("intro-heading").children, function (t) {
    t.addEventListener("mouseover", function () {
      forEach(a, function (e) {
        removeClass(t, e)
      }), addClass(t, a[Math.floor(a.length * Math.random())])
    }), t.addEventListener("click", function () {
      toggleClass(t, "intro--flip")
    })
  });
  document.getElementById("intro-bg")
}

function tileInitMore(e) {
  var t = document.getElementById("more-canvas");
  e.data = {
    noise: new SimplexNoise,
    puffs: [],
    delta: 700,
    addInterval: 390,
    moveSpeed: 1
  }, initCanvasAndAppend(t, e), t.addEventListener("click", function () {})
}

function tileUpdateMore(e, t, a) {
  if (e.isActive || 0 < t.puffs.length) {
    updateTileMousePixels(e, 1), e.isActive && (t.delta += a), e.isActive && t.delta > (mouse.down ? t.addInterval / 3 : t.addInterval) && (t.puffs.push(new Puff(e.mouse.x * t.dpi, e.mouse.y * t.dpi)), t.delta = 0);
    for (var n = t.puffs.length, o = 0; o < n; o++) {
      var i = t.puffs[o];
      i.x += i.vel * i.xRatio * t.moveSpeed * a / 16, i.y += i.vel * i.yRatio * t.moveSpeed * a / 16, i.vel *= .96, i.rad *= 1 + .02 * i.vel, i.scale += (1 - i.scale) / (240 / a), i.vel < .01 && (t.puffs.splice(o, 1), o--, n--)
    }
    e.drawRequired = !0
  }
}

function Puff(e, t) {
  this.x = e, this.y = t;
  var a = Math.random() * Math.PI * 2,
    n = 25 * Math.random() + 5,
    o = 3 + n / 12;
  this.angle = a, this.vel = o, this.startVel = o, this.xRatio = Math.cos(a), this.yRatio = Math.sin(a), this.rad = n, this.scale = 0
}

function tileDrawMore(e, t) {
  (e.isActive || 0 < t.puffs.length) && t.puffs.forEach(function (e) {
    t.ctx.strokeStyle = color.green, t.ctx.beginPath(), t.ctx.arc(e.x + e.vel * e.xRatio, e.y + e.vel * e.yRatio, .9 * e.rad * e.scale, 0, 2 * Math.PI), t.ctx.stroke(), t.ctx.strokeStyle = color.khaki, t.ctx.beginPath(), t.ctx.arc(e.x, e.y, e.rad * e.scale, 0, 2 * Math.PI), t.ctx.stroke()
  })
}

function tileInitNe(e) {
  e.data = {
    ne: document.getElementById("ne"),
    grad: document.getElementById("grad"),
    word: ["ne", "i", "sa", "n", "to", "u", "ki", "xyo", "u2"],
    index: 1,
    timer: 260,
    speed: 260,
    char: ["根", 1],
    characters: {
      ne: [["ネ", 1], ["ね", 1], ["峯", 1], ["禰", 1], ["寢", 1], ["祢", 1], ["音", 1], ["根", 1], ["値", 1], ["峰", 1], ["氒", 1], ["爇", 1]],
      i: [["イ", 1], ["い", 1], ["意", 1], ["胃", 1], ["伊", 1], ["井", 1], ["居", 1], ["医", 1], ["移", 1], ["委", 1], ["以", 1], ["違", 1], ["位", 1], ["遺", 1], ["維", 1], ["寧", 2], ["濘", 2], ["獰", 2], ["芮", 2], ["汭", 2], ["侫", 2], ["儜", 2], ["蜹", 2], ["佞", 2], ["檸", 2]],
      sa: [["サ", 1], ["さ", 1], ["差", 1], ["左", 1], ["小", 1], ["作", 1], ["査", 1], ["再", 1], ["然", 1], ["勇", 2], ["諌", 2]],
      n: [["ン", 1], ["ん", 1], ["三", 2], ["山", 2], ["算", 2], ["参", 2], ["産", 2], ["様", 2], ["残", 2], ["散", 2], ["酸", 2], ["賛", 2], ["杉", 2], ["尽", 2], ["惨", 2], ["操", 2], ["傘", 2], ["燦", 2], ["蚕", 2], ["珊", 2], ["纂", 2]],
      to: [["ト", 1], ["と", 1], ["十", 1], ["度", 1], ["土", 1], ["都", 1], ["戸", 1], ["門", 1], ["図", 1], ["登", 1]],
      u: [["ウ", 1], ["う", 1], ["卯", 1], ["優", 1], ["鵜", 1], ["于", 1], ["宇", 1], ["禹", 1], ["生", 1], ["右", 1], ["売", 1], ["得", 1], ["有", 1], ["羽", 1], ["雨", 1], ["優", 1], ["東", 2], ["当", 2], ["党", 2], ["統", 2], ["投", 2], ["島", 2], ["道", 2], ["藤", 2], ["頭", 2], ["答", 2], ["刀", 2], ["豆", 2], ["等", 2]],
      ki: [["キ", 1], ["き", 1], ["気", 1], ["木", 1], ["機", 1], ["期", 1], ["記", 1], ["来", 1], ["浮", 2]],
      xyo: [["ョ", 1], ["ょ", 1], ["許", 2], ["巨", 2], ["去", 2], ["挙", 2], ["拠", 2], ["拒", 2], ["居", 2], ["距", 2]],
      u2: [["ウ", 1], ["う", 1], ["卯", 1], ["優", 1], ["鵜", 1], ["于", 1], ["宇", 1], ["禹", 1], ["生", 1], ["右", 1], ["売", 1], ["得", 1], ["有", 1], ["羽", 1], ["雨", 1], ["優", 1], ["協", 3], ["教", 3], ["経", 3], ["京", 3], ["強", 3], ["続", 3], ["校", 3], ["共", 3], ["橋", 3], ["興", 3], ["供", 3], ["狂", 3]]
    },
    angle: 0,
    angleSpeed: 1.5,
    skew: 0
  }
}

function tileUpdateNe(e, a, n) {
  if (e.isActive) {
    if (updateTileMouseRelative(e, 10, n), a.angle += a.angleSpeed, mouse.down ? a.angleSpeed += .1 : a.angleSpeed += (1.5 - a.angleSpeed) / 100, 90 <= a.angle && (a.angle -= 180), a.skew += Math.sin(t / 1e3) / 8, a.timer -= n, a.timer <= 0) {
      a.timer += a.speed;
      var o = a.word[a.index],
        i = a.characters[o];
      a.char = i[Math.floor(Math.random() * i.length)], mouse.down && (a.char = i[1]), a.ne.innerText = a.char[0], a.index -= a.char[1], a.index < 0 && (a.index = a.word.length - 1)
    }
    e.drawRequired = !0
  }
}

function tileDrawNe(e, t) {
  t.ne.style.transform = getTransform(e)
}

function getTransform(e) {
  return "rotateY(" + e.data.angle + "deg) rotateZ(" + e.data.skew + "deg) translateX(" + 30 * e.mouse.x + "%) translateY(" + 30 * e.mouse.y + "%)"
}

function tileInitPacman(e) {
  e.data = {
    phrase: "<span> </span><span>t</span><span>a</span><span>l</span><span>k</span><span> </span><span>i</span><span>s</span><span> </span><span>c</span><span>h</span><span>e</span><span>a</span><span>p</span><span> </span><span>—</span><span> </span><span>g</span><span>e</span><span>t</span><span> </span><span>i</span><span>n</span><span> </span><span>t</span><span>o</span><span>u</span><span>c</span><span>h</span><span> </span><span>—</span>",
    text: e.el.getElementsByClassName("pacman__text")[0],
    remove: e.el.getElementsByClassName("pacman__remove")[0],
    phrases: e.el.getElementsByClassName("pacman__phrase"),
    letters: [],
    offset: 0
  }, e.data.phraseWidth = e.data.phrases[0].offsetWidth, e.data.lastPhrase = e.data.phrases[e.data.phrases.length - 1], e.data.maxSpeed = e.data.phraseWidth / 180, e.data.speed = 0, e.data.acc = 20, e.data.letterSpeed = 5, e.data.angleSpeed = 30, e.data.grav = .1, e.data.diss = .999, e.data.yCutoff = e.el.getBoundingClientRect().height / 2
}

function tileUpdatePacman(e, a, t) {
  if (e.isActive || .4 < e.data.speed) {
    if (a.speed += (e.isActive ? a.maxSpeed - a.speed : -a.speed) / e.data.acc, a.offset += a.speed * t / 16, .4 < a.speed ? addClass(e.el, "pacman--chomp") : removeClass(e.el, "pacman--chomp"), a.offset >= a.phraseWidth) {
      var n = document.createElement("div");
      addClass(n, "pacman__phrase"), n.innerHTML = a.phrase, a.lastPhrase = n, a.text.append(n), a.phrases = e.el.getElementsByClassName("pacman__phrase"), a.offset -= a.phraseWidth
    }
    forEach(a.phrases, function (e, t) {
      e.style.transform = "translateX(" + a.offset + "px)", 0 == e.children.length && e.remove()
    });
    for (var o = 0; o < a.lastPhrase.children.length; o++) {
      (i = a.lastPhrase.children[o]).getBoundingClientRect().left >= .9375 * window.innerWidth && (a.remove.append(i), a.letters.push(new Letter(i, a)), o--)
    }
    for (o = 0; o < a.letters.length; o++) {
      var i;
      (i = a.letters[o]).pos.x += i.vel.x * t / 16, i.pos.y += i.vel.y * t / 16, i.angle += i.rot, i.vel.y += a.grav, i.vel.x += i.rot / 300, i.vel.x *= a.diss, i.rot *= a.diss, i.pos.y > a.yCutoff && (i.el.remove(), a.letters.splice(o, 1), o--)
    }
    e.drawRequired = !0
  }
}

function Letter(e, t) {
  this.el = e, this.pos = {
    x: 0,
    y: 0
  }, this.vel = {
    x: -Math.random() * t.letterSpeed,
    y: -Math.random() * t.letterSpeed
  }, this.rot = (Math.random() - .5) * t.angleSpeed * 2, this.angle = 0
}

function tileDrawPacman(e, t) {
  forEach(t.letters, function (e) {
    e.el.style.transform = "translate3d(" + e.pos.x + "px, " + e.pos.y + "px, 0) rotate(" + e.angle + "deg)"
  })
}

function tileInitPetals(e) {
  var t = document.getElementById("petals-canvas");
  e.data = {
    noise: new SimplexNoise,
    trail: [],
    maxlength: 50,
    spread: 80,
    count: 50
  }, initCanvasAndAppend(t, e)
}

function tileUpdatePetals(e, t, a) {
  (e.isActive || 0 < t.trail.length) && (updateTileMousePixels(e, 10), t.trail.unshift([e.mouse.x * e.data.dpi, e.mouse.y * e.data.dpi]), (t.trail.length > t.maxlength || !e.isActive) && t.trail.pop(), e.drawRequired = !0)
}

function tileDrawPetals(e, a) {
  e.data.ctx.strokeStyle = mouse.down ? color.green : color.purple, a.ctx.globalCompositeOperation = "destination-out", a.ctx.globalAlpha = mouse.down ? .01 : .1, e.data.ctx.fillStyle = color.white, a.ctx.fillRect(0, 0, a.cw, a.ch), a.ctx.globalCompositeOperation = mouse.down ? "xor" : "source-over", a.ctx.globalAlpha = .2, a.ctx.beginPath();
  for (var n = 0, o = 0, i = 0, s = 0, r = 0; r < a.count; r++)
    for (var l = 0; l < a.trail.length; l++) n = a.trail[l][0], o = a.trail[l][1], i = n + a.noise.noise3D(n / 300, o / 500, r / 35 + t / 3e3) * a.spread, s = o + a.noise.noise3D(n / 300, o / 500, r / 35 + t / 3e3 + 1e3) * a.spread, a.ctx[0 == l ? "moveTo" : "lineTo"](i, s);
  a.ctx.stroke()
}

function tileInitPixel(e) {
  var t = document.createElement("canvas"),
    a = document.getElementById("pixel-canvas"),
    n = a.getContext("2d");
  n.imageSmoothingEnabled = !1, e.data = {
    outputCanvas: a,
    outputCtx: n,
    pixels: [],
    noise: new SimplexNoise,
    t: 0,
    x: 0,
    y: 0,
    flip: !0
  }, initCanvasAndAppend(t, e), tileResizePixel.bind(e)(), resizeQueue.push(tileResizePixel.bind(e)), a.addEventListener("click", function () {
    e.data.flip = !e.data.flip
  })
}

function tileResizePixel() {
  var e = this,
    t = e.data.canvas;
  e.data.pixels = [], e.data.resolution = 7 * e.data.dpi / 2, t.width = Math.floor(t.width / e.data.resolution), t.height = Math.floor(t.height / e.data.resolution), e.data.cw = t.width, e.data.ch = t.height;
  for (var a = 0; a < e.data.cw; a++) {
    e.data.pixels[a] = [];
    for (var n = 0; n < e.data.ch; n++) e.data.pixels[a][n] = 0
  }
  e.updateRequired = !0
}

function tileUpdatePixel(e, t, a) {
  if (e.isActive || e.isFirstFrame || e.updateRequired) {
    updateTileMouseRelative(e, 30), t.x -= e.mouse.x / 2, t.y -= e.mouse.y / 2, t.t += a;
    for (var n = 0; n < e.data.cw; n++)
      for (var o = 0; o < e.data.ch; o++) e.data.pixels[n][o] = t.noise.noise3D((n + t.x) / 40, (o + t.y) / 40, t.t / 4e3);
    e.drawRequired = !0, e.updateRequired = !1
  }
}

function tileDrawPixel(e, t) {
  t.ctx.clearRect(0, 0, t.cw, t.ch);
  for (var a = 0; a < e.data.cw; a++)
    for (var n = 0; n < e.data.ch; n++) {
      var o = e.data.pixels[a][n],
        i = !t.flip;
      .6 < o ? i = t.flip : .2 < o ? a % 2 == 0 && n % 2 == 0 || (i = t.flip) : -.2 < o ? (a + n) % 2 != 0 && (i = t.flip) : -.6 < o && a % 2 != 0 && n % 2 != 0 && (i = t.flip), t.ctx.fillStyle = i ? color.khaki : color.white, t.ctx.fillRect(a, n, 1, 1)
    }
  var s = Math.ceil(t.outputCanvas.width / t.canvas.width),
    r = Math.ceil(t.outputCanvas.height / t.canvas.height);
  t.outputCtx.drawImage(t.canvas, 0, 0, t.canvas.width * s, t.canvas.height * r)
}

function tileInitProject(e) {
  var t = e.el.getElementsByClassName("js-projectTitle")[0],
    a = t.getAttribute("data-project-title");
  e.data = {
    pt: 0,
    ptClip: 0,
    titleEl: t,
    title: a,
    titleLen: a.length,
    time: 0,
    interval: 120
  }
}

function tileUpdateProject(e, t, a) {
  e.firstActiveFrame && (t.delta = 0, t.pt = 0, t.ptClip = 0), e.isActive && (t.time += a, t.time >= t.interval && (t.pt++, t.ptClip = t.pt % t.titleLen, t.time -= t.interval), e.drawRequired = !0)
}

function tileDrawProject(e, t) {
  e.isActive && (t.titleEl.innerHTML = t.title[t.ptClip])
}

function tileInitSlash(e) {
  var a = "/-\\|=+:~_¥&%$1234567890^*<>#()",
    t = document.getElementById("slash-inner"),
    n = t.children;
  forEach(n, function (e) {
    e.addEventListener("mouseover", function () {
      this.innerHTML = a[Math.floor(a.length * Math.random())]
    })
  }), t.addEventListener("click", function () {
    var t = a[Math.floor(a.length * Math.random())];
    forEach(n, function (e) {
      e.innerHTML = t
    })
  })
}

function tileInitSoul(e) {
  var t = document.getElementById("soul-canvas");
  e.data = {
    rad: 60,
    noise: new SimplexNoise,
    colorIndex: 0,
    colorProgress: 0,
    colors: [color.khaki, color.purple, color.purple, color.red, color.red, color.yellow, color.yellow, color.green, color.green, color.khaki]
  }, initCanvasAndAppend(t, e)
}

function tileUpdateSoul(e, a, n) {
  e.isActive && (updateTileMousePixels(e, mouse.down && !isMobile ? 10 : 20), e.mouse.x += a.noise.noise2D(e.mouse.x / 100, t / 2e3), e.mouse.y += a.noise.noise2D(e.mouse.y / 100, t / 2e3), e.drawRequired = !0)
}

function tileDrawSoul(e, t) {
  t.ctx.globalCompositeOperation = "destination-out", t.ctx.globalAlpha = .01, e.data.ctx.fillStyle = color.white, t.ctx.fillRect(0, 0, t.cw, t.ch), t.ctx.globalCompositeOperation = "source-over", t.ctx.globalAlpha = 1, t.colorProgress += mouse.down ? .05 : .003, 1 <= t.colorProgress && (t.colorIndex++, t.colorIndex >= t.colors.length && (t.colorIndex = 0), t.colorProgress = 0);
  var a = t.colors[t.colorIndex];
  if (t.colorIndex == t.colors.length - 1) var n = t.colors[0];
  else n = t.colors[t.colorIndex + 1];
  e.data.ctx.fillStyle = lerpColor(a, n, t.colorProgress), t.ctx.beginPath(), t.ctx.arc(e.mouse.x * t.dpi, e.mouse.y * t.dpi, t.rad * t.dpi / 2, 0, 2 * Math.PI), t.ctx.fill()
}

function lerpColor(e, t, a) {
  var n = parseInt(e.replace(/#/g, ""), 16),
    o = n >> 16,
    i = n >> 8 & 255,
    s = 255 & n,
    r = parseInt(t.replace(/#/g, ""), 16);
  return "#" + ((1 << 24) + (o + a * ((r >> 16) - o) << 16) + (i + a * ((r >> 8 & 255) - i) << 8) + (s + a * ((255 & r) - s)) | 0).toString(16).slice(1)
}

function tileInitSpheres(e) {
  initCanvasAndAppend(document.getElementById("spheres-canvas"), e), e.data.operations = ["source-over", "source-atop", "destination-over", "destination-out", "lighter", "xor", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], e.data.spheres = [new Sphere(.35 * e.data.cw, .4 * e.data.ch, r(), r(), .45 * e.data.cw / 2, e), new Sphere(.65 * e.data.cw, .6 * e.data.ch, r(), r(), .45 * e.data.cw / 2, e)], e.data.ctx.globalCompositeOperation = "xor", e.data.g = 98e-6, e.el.addEventListener("click", function () {
    e.data.spheres.push(new Sphere(e.mouse.x * e.data.dpi + 10 * r(), e.mouse.y * e.data.dpi + 10 * r(), r(), r(), e.data.cw * (.01 + Math.random() / 6), e))
  }), resizeQueue.push(tileResizeSpheres.bind(e))
}

function tileResizeSpheres() {
  this.data.ctx.globalCompositeOperation = "xor";
  var t = this.resizeRatio;
  this.data.spheres.forEach(function (e) {
    e.x *= t, e.y *= t, e.startX *= t, e.startY *= t, e.xVel *= t, e.yVel *= t, e.rad *= t
  })
}

function r() {
  return Math.random() - .5
}

function Sphere(e, t, a, n, o, i) {
  this.x = e, this.y = t, this.startX = e, this.startY = t, this.xVel = 2 * a, this.yVel = 2 * n, this.rad = o
}

function tileUpdateSpheres(c, e, t) {
  if (c.isActive || c.isFirstFrame) {
    updateTileMousePixels(c, 1, t);
    var a = (mouse.down, 1);
    forEach(e.spheres, function (i) {
      var s = 0,
        r = 0,
        l = {
          x: c.mouse.x * e.dpi,
          y: c.mouse.y * e.dpi,
          rad: 1
        };
      forEach(e.spheres, function (e) {
        var t = !1;
        i == e && (t = !0, e = l);
        var a = getVectorDist(i.x, i.y, e.x, e.y),
          n = getAngle(e.x - i.x, e.y - i.y),
          o = c.data.g * (i.rad * e.rad) / Math.pow(a, 1.5);
        a < i.rad + e.rad && (o *= -1), t && (o *= 300), s += Math.cos(n / 180 * Math.PI) * o, r += Math.sin(n / 180 * Math.PI) * o
      }), i.xVel += s * i.rad, i.yVel += r * i.rad, i.xVel *= .95, i.yVel *= .95, i.x += i.xVel * t / 16 * a * dpi / 2, i.y += i.yVel * t / 16 * a * dpi / 2, i.x - i.rad <= 0 && (i.xVel *= -1, i.x = i.rad), i.x + i.rad >= e.cw && (i.xVel *= -1, i.x = e.cw - i.rad), i.y - i.rad <= 0 && (i.yVel *= -1, i.y = i.rad), i.y + i.rad >= e.ch && (i.yVel *= -1, i.y = e.ch - i.rad)
    }), c.drawRequired = !0
  }
}

function tileDrawSpheres(e, a) {
  a.ctx.clearRect(0, 0, a.cw, a.ch), forEach(a.spheres, function (e) {
    var t = a.ctx.createRadialGradient(e.x, e.y, 1.1 * e.rad, e.x - .2 * e.rad, e.y - .3 * e.rad, 0);
    t.addColorStop(0, color.black), t.addColorStop(.9, color.white), t.addColorStop(1, color.white), a.ctx.fillStyle = t, a.ctx.beginPath(), a.ctx.arc(e.x, e.y, e.rad, 0, 2 * Math.PI), a.ctx.fill()
  })
}

function tileInitStripes(e) {
  var t = document.getElementById("stripes-canvas");
  e.data = {
    stripeCount: 30,
    stripePoints: 30,
    offsetAmount: 50,
    repelForce: 10,
    dissapationRatio: .85,
    stripes: []
  }, isMobile && (e.data.stripeCount *= .7, e.data.stripePoints *= .5), initCanvasAndAppend(t, e), tileResizeStripes.bind(e)(), resizeQueue.push(tileResizeStripes.bind(e));
  for (var a = 1; a < e.data.stripeCount; a++) e.data.stripes.push(new Stripe(a * e.data.cw / e.data.stripeCount * .62, e.data.stripePoints))
}

function tileResizeStripes() {
  this.data.ctx.lineWidth = 2 * this.data.dpi / 2, this.data.ctx.lineJoin = "round", this.data.ctx.lineCap = "round", this.data.ctx.strokeStyle = color.white;
  var t = this.resizeRatio;
  this.data.stripes.forEach(function (e) {
    e.x *= t
  })
}

function Stripe(e, t) {
  this.x = e, this.points = [];
  for (var a = 0; a < t; a++) this.points.push([0, 0])
}

function tileUpdateStripes(e, t, a) {
  if (e.isActive) {
    updateTileMousePixels(e, 1), isMobile && (e.mouse.x = e.bounds.width - e.mouse.x);
    for (var n = 0; n < t.stripeCount - 1; n++)
      for (var o = t.stripes[n], i = 1; i < t.stripePoints - 1; i++) {
        var s = o.x + o.points[i][0] * t.offsetAmount,
          r = i * (t.ch / (t.stripePoints - 1));
        if (e.isActive) {
          var l = getVectorDist(s, r, e.mouse.x * t.dpi, e.mouse.y * t.dpi),
            c = mouse.down ? -1 * t.repelForce : t.repelForce;
          isMobile && (c *= -1);
          var d = mouse.down ? .8 * t.dissapationRatio : t.dissapationRatio;
          o.points[i][1] += 1 / Math.pow(l, d) * c * sign(s - e.mouse.x * t.dpi)
        }
        o.points[i][1] -= o.points[i][0] / 1.1, o.points[i][1] *= .97, o.points[i][0] += o.points[i][1] * a / 16, o.points[i][0] += (((0 < i ? o.points[i - 1][0] : 0) + (i < t.stripePoints - 2 ? o.points[i + 1][0] : 0)) / 2 - o.points[i][0]) / 1.01
      }
    e.drawRequired = !0
  }
}

function tileDrawStripes(e, t) {
  t.ctx.clearRect(0, 0, t.cw, t.ch);
  for (var a = 0; a < t.stripeCount - 1; a++) {
    var n = t.stripes[a];
    t.ctx.beginPath(), t.ctx.moveTo(n.x, 0);
    for (var o = 1; o < t.stripePoints - 1; o++) t.ctx.lineTo(n.x + n.points[o][0] * t.offsetAmount, o * (t.ch / (t.stripePoints - 1)));
    t.ctx.lineTo(n.x, t.ch), t.ctx.stroke()
  }
}

function tileInitSynth(e) {
  var t = new(window.AudioContext || window.webkitAudioContext)({
    latencyHint: "interactive",
    sampleRate: 22050
  });
  e.data = {
    context: t,
    notes: ["E3", "D3", "E3", "G3", "E4", "D4", "E4", "G4", "C4", "D4", "C4", "C5", "E4", "E5", "G4", "G3"],
    notesActive: [!0, !1, !0, !1, !0, !0, !0, !0, !1, !1, !0, !1, !0, !1, !0, !0],
    drums: {
      B: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
      S: [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
      H: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      C: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]
    },
    noteIndex: 15,
    bpm: 88,
    noteDivision: 4,
    nextTick: t.currentTime,
    counter: 0,
    sequencerPlaying: !1,
    started: !1
  }, e.data.drums = {
    B: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
    S: [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    H: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    C: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  }, e.data.tickInterval = 60 / e.data.bpm / e.data.noteDivision, initCanvasAndAppend(document.getElementById("waveform-canvas"), e, !0), e.data.analyser = t.createAnalyser(), e.data.analyser.fftSize = 1024, e.data.bufferLength = e.data.analyser.frequencyBinCount, e.data.dataArray = new Uint8Array(e.data.bufferLength), createSynth(e.data), createDrums(e.data), synthLoad(e.data), initSynthInteractions(e.data, e)
}

function tileUpdateSynth(e, t, a) {
  t.sequencerPlaying ? (runSequencer(t, a), e.drawRequired = !0, e.updateRequired = !0) : e.updateRequired = !1, calculateWaveform(t)
}

function tileDrawSynth(e, t) {
  showActiveNode(t), drawWaveform(t)
}

function runSequencer(e, t) {
  if (e.sequencerPlaying && e.nextTick < e.context.currentTime + .1) {
    e.noteIndex++, e.noteIndex >= e.notes.length && (e.noteIndex = 0);
    var a = getGroove(e);
    if (e.notesActive[e.noteIndex]) playNote(e.notes[e.noteIndex], Math.max(0, e.nextTick + a), e);
    playDrums(e, Math.max(0, e.nextTick + a)), e.nextTick += e.tickInterval, e.context.currentTime - e.nextTick > 4 * e.tickInterval && (e.nextTick = e.context.currentTime)
  }
}

function playNote(e, t, a) {
  a.amp.gain.cancelScheduledValues(t), a.amp.gain.setTargetAtTime(1, t, a.ampEnv.attack), a.amp.gain.setTargetAtTime(a.ampEnv.sustain, t + a.ampEnv.attack, a.ampEnv.decay), a.amp.gain.setTargetAtTime(1e-5, t + a.noteLength * a.tickInterval, a.ampEnv.release), a.lowpass.frequency.setTargetAtTime(Math.min(12e3, Math.max(1, a.lowpassFreq + a.lowpassEnv)), t, a.voltEnv.attack), a.lowpass.frequency.setTargetAtTime(Math.min(12e3, Math.max(1, a.lowpassFreq + a.lowpassEnv * a.voltEnv.sustain)), t + a.voltEnv.attack, a.voltEnv.decay), a.lowpass.frequency.setTargetAtTime(a.lowpassFreq, t + a.noteLength * a.tickInterval, a.voltEnv.release), a.highpass.frequency.setTargetAtTime(Math.max(1, a.highpassFreq - a.highpassEnv), t, a.voltEnv.attack), a.highpass.frequency.setTargetAtTime(Math.max(1, a.highpassFreq - a.highpassEnv * a.voltEnv.sustain), t + a.voltEnv.attack, a.voltEnv.decay), a.highpass.frequency.setTargetAtTime(a.highpassFreq, t + a.noteLength * a.tickInterval, a.voltEnv.release), a.reverbOffGain.gain.value = 1 - .9 * a.reverbGain.gain.value, a.distortionDry.gain.value = 1 - a.distortionWet.gain.value;
  var n = 1.05946274;
  a.osc1Note = getNoteOffset(e, 12 * Math.round(a.osc1Octave) + Math.round(a.osc1Semi)), a.osc1Freq = getNoteFrequency(a.osc1Note) * Math.pow(n, a.osc1Pitch) * Math.pow(n, a.oscPitch), a.osc1.frequency.setTargetAtTime(a.osc1Freq, t, a.portamento), a.osc2Note = getNoteOffset(e, 12 * Math.round(a.osc2Octave) + Math.round(a.osc2Semi)), a.osc2Freq = getNoteFrequency(a.osc2Note) * Math.pow(n, a.osc2Pitch) * Math.pow(n, a.oscPitch), a.osc2.frequency.setTargetAtTime(a.osc2Freq, t, a.portamento)
}

function playDrums(e, t) {
  1 == e.drums.B[e.noteIndex] && e.kick && e.kick.play(t), 1 == e.drums.S[e.noteIndex] && e.snare && e.snare.play(t), 1 == e.drums.H[e.noteIndex] && e.hihat && e.hihat.play(t), 1 == e.drums.C[e.noteIndex] && e.cymbal && e.cymbal.play(t)
}

function createSynth(t) {
  var a;
  t.osc1 = t.context.createOscillator(), t.osc1.type = "sine", t.osc1.frequency.value = getNoteFrequency(t.notes[0]), t.osc1Octave = 0, t.osc1Semi = 0, t.osc1Fine = 0, t.osc1Pitch = 0, t.osc1Level = t.context.createGain(), t.osc2 = t.context.createOscillator(), t.osc2.type = "square", t.osc2.frequency.value = getNoteFrequency(t.notes[0]), t.osc2Octave = -1, t.osc2Semi = 0, t.osc2Fine = 0, t.osc2Pitch = 0, t.osc2Level = t.context.createGain(), t.osc2Level.gain.value = .5, t.distortion = t.context.createWaveShaper(), t.distortion.curve = function (e) {
    for (var t, a = "number" == typeof e ? e : 50, n = new Float32Array(44100), o = Math.PI / 180, i = 0; i < 44100; ++i) {
      var s = (3 + a) * (t = 2 * i / 44100 - 1) * 20 * o / (Math.PI + a * Math.abs(t));
      n[i] = s
    }
    return n
  }(400), t.distortion.oversample = "4x", t.distortionWet = t.context.createGain(), t.distortionWet.gain.value = 0, t.distortionDry = t.context.createGain(), t.lowpass = t.context.createBiquadFilter(), t.lowpass.type = "lowpass", t.lowpass.frequency.value = 1e4, t.lowpass.Q.value = 1, t.lowpassEnv = 1, t.lowpassFreq = 1e4, t.highpass = t.context.createBiquadFilter(), t.highpass.type = "highpass", t.highpass.frequency.value = 1, t.highpass.Q.value = 1, t.highpassFreq = 1, t.highpassEnv = 0, t.reverb = t.context.createConvolver(), t.reverbGain = t.context.createGain(), t.reverbGain.gain.value = 0, t.reverbOffGain = t.context.createGain(), t.reverbOffGain.gain.value = 1;
  var e = new XMLHttpRequest;
  e.open("get", "/sounds/ir-synth-min.wav", !0), e.responseType = "arraybuffer", e.onload = function () {
    t.context.decodeAudioData(e.response, function (e) {
      a = e, t.reverb.buffer = a
    })
  }, e.send(), t.delay = t.context.createDelay(2), t.delay.delayTime.value = .507, t.delayFeedback = t.context.createGain(), t.delayFeedback.gain.value = 0, t.delayBus = t.context.createGain(), t.amp = t.context.createGain(), t.amp.gain.value = 1e-5, t.master = t.context.createGain(), t.master.gain.value = .5, t.noteLength = .75, t.grooveAmount = -.105, t.grooveTime = t.tickInterval, t.portamento = .001, t.oscLevel = t.context.createGain(), t.oscLevel.gain.value = .35, t.oscLevelInput = 1, t.oscFine = 0, t.oscPitch = 0, t.ampEnv = {
    attack: .1,
    sustain: 1,
    decay: .1,
    release: .5
  }, t.voltEnv = {
    attack: .01,
    sustain: 0,
    decay: .02,
    release: .01
  }, t.compressor = t.context.createDynamicsCompressor(), t.compressor.threshold.value = -30, t.compressor.knee.value = 40, t.compressor.ratio.value = 2, t.compressor.attack.value = .1, t.compressor.release.value = .25, t.osc1.connect(t.osc1Level), t.osc1Level.connect(t.oscLevel), t.osc2.connect(t.osc2Level), t.osc2Level.connect(t.oscLevel), t.oscLevel.connect(t.amp), t.amp.connect(t.lowpass), t.lowpass.connect(t.highpass), t.highpass.connect(t.distortionDry), t.highpass.connect(t.distortionWet), t.distortionDry.connect(t.delayBus), t.distortionDry.connect(t.delayFeedback), t.distortionWet.connect(t.distortion), t.distortion.connect(t.delayBus), t.distortion.connect(t.delayFeedback), t.delayFeedback.connect(t.delay), t.delay.connect(t.delayFeedback), t.delayFeedback.connect(t.delayBus), t.delayBus.connect(t.reverb), t.delayBus.connect(t.reverbOffGain), t.reverbOffGain.connect(t.compressor), t.reverb.connect(t.reverbGain), t.reverbGain.connect(t.compressor), t.compressor.connect(t.master), t.master.connect(t.context.destination), t.master.connect(t.analyser), t.analyser.connect(t.context.destination)
}

function createDrums(t) {
  var a;
  t.drumReverb = t.context.createConvolver(), t.drumReverbGain = t.context.createGain(), t.drumReverbGain.gain.value = .2, t.drumGain = t.context.createGain(), t.drumGain.gain.value = 2.2, t.drumMaster = t.context.createGain(), t.drumMaster.gain.value = .5, t.drumGain.connect(t.drumMaster), t.drumReverbGain.connect(t.drumMaster), t.drumMaster.connect(t.compressor);
  var e = new XMLHttpRequest;
  e.open("get", "/sounds/ir-min.wav", !0), e.responseType = "arraybuffer", e.onload = function () {
    t.context.decodeAudioData(e.response, function (e) {
      a = e, t.drumReverb.buffer = a, t.drumReverb.connect(t.drumReverbGain), t.kick = audioFileLoader("/sounds/kick.wav", t), t.snare = audioFileLoader("/sounds/snare.wav", t), t.hihat = audioFileLoader("/sounds/hihat.wav", t), t.cymbal = audioFileLoader("/sounds/cymbal.wav", t)
    })
  }, e.send()
}

function audioFileLoader(e, t, a) {
  var n = void 0,
    o = {};
  o.fileDirectory = e;
  var i = new XMLHttpRequest;
  return i.open("GET", o.fileDirectory, !0), i.responseType = "arraybuffer", i.onload = function () {
    t.context.decodeAudioData(i.response, function (e) {
      o.soundToPlay = e
    })
  }, i.send(), o.play = function (e) {
    (n = t.context.createBufferSource()).buffer = o.soundToPlay, n.connect(t.drumReverb), n.connect(t.drumGain), n.start(e)
  }, o.stop = function (e) {
    n.stop(t.context.currentTime + e || t.context.currentTime)
  }, o
}

function getNoteFrequency(e) {
  return noteValues[e]
}

function getOctaveOffset(e, t) {
  return e = e.substring(0, e.length - 1) + Math.max(0, Number(e[e.length - 1]) + t)
}

function getNoteOffset(e, t) {
  var a = e.substring(0, e.length - 1),
    n = noteLetters.indexOf(a);
  n += t;
  var o = noteLetters[(100 * noteLetters.length + n) % noteLetters.length],
    i = Number(e[e.length - 1]);
  return o + Math.max(0, Math.min(7, i + Math.floor(n / noteLetters.length)))
}

function getGroove(e) {
  switch (e.noteIndex * (4 / e.noteDivision) % 2) {
    case 0:
      return 1 * e.grooveAmount * e.grooveTime;
    case 1:
      return -1 * e.grooveAmount * e.grooveTime
  }
}

function initSynthInteractions(o, e) {
  o.playButton = document.getElementById("synth-play"), o.bpmInput = document.getElementById("synth-bpm"), o.swingInput = document.getElementById("synth-swing"), o.synthSequencerNodes = document.getElementById("synth-nodes").children, o.synthDrumNodes = document.getElementsByClassName("sequencer__drum"), o.synthKnobs = document.getElementsByClassName("synth__knobOuter"), o.synthButtons = document.getElementsByClassName("synth__buttonInputInner"), o.synthSelects = document.getElementsByClassName("synth__select"), o.holdingKnob = null, o.knobInput = 0, o.knobInner = 0, o.knobValue = 0, o.knobMin = 0, o.knobMax = 0, o.knobIncrement = 1, o.knobParam = "", o.startX = 0, o.startY = 0, o.holdingNode = null, o.nodeIndex = 0, o.nodeStart = null, o.nodeFinal = null, o.noteChanged = !1, o.activeNodes = document.getElementById("synth-nodes"), window.addEventListener("mousemove", function (e) {
    if (o.holdingKnob) {
      var t = e.clientX - o.startX - (e.clientY - o.startY);
      o.knobValue = Math.max(o.knobMin, Math.min(o.knobMax, o.knobValue + t * o.knobIncrement)), o.startX = e.clientX, o.startY = e.clientY, updateParam(o.knobParam, o.knobValue, o), o.knobInput.value = String(o.knobValue).substring(0, 5), o.knobInner.style.transform = "rotate(" + ((o.knobValue - o.knobMin) / o.knobIncrement * 1.5 - 150) + "deg)"
    }
    if (o.holdingNode) {
      var a = absFloor((t = e.clientX - o.startX - (e.clientY - o.startY)) / 10);
      o.nodeFinal = getNoteOffset(o.nodeStart, a), o.nodeFinal != o.nodeStart && (o.noteChanged = !0), o.notes[o.nodeIndex] = o.nodeFinal, o.holdingNode.children[1].value = o.nodeFinal
    }
  }), window.addEventListener("mouseup", function () {
    o.holdingKnob && (o.holdingKnob = null), o.holdingNode && (o.noteChanged || (o.notesActive[o.nodeIndex] = !o.notesActive[o.nodeIndex], o.holdingNode.children[0].checked = !o.holdingNode.children[0].checked), o.holdingNode = null), synthSave(o)
  }), forEach(o.synthKnobs, function (a, e) {
    a.addEventListener("mousedown", function (e) {
      var t = (o.holdingKnob = a).getElementsByTagName("input")[0];
      o.knobInput = t, o.knobInner = a.children[0], o.knobValue = Number(t.value), o.knobMin = Number(t.getAttribute("data-min")), o.knobMax = Number(t.getAttribute("data-max")), o.knobIncrement = (o.knobMax - o.knobMin) / 200, o.knobParam = t.getAttribute("data-param"), e && (o.startX = e.clientX, o.startY = e.clientY)
    }), initKnob(a, o)
  }), forEach(o.synthButtons, function (e, t) {
    e.addEventListener("change", function (e) {
      var t = this.value;
      updateParam(this.getAttribute("data-param"), t, o), synthSave(o)
    }), e.value == getParam(e.getAttribute("data-param"), o) && (e.checked = !0)
  }), o.playButton.addEventListener("click", function () {
    toggleSequencerPlaying(o)
  }), document.getElementById("show-synth").addEventListener("change", function () {
    this.checked && (o.activeNodes = document.getElementById("synth-nodes"), document.getElementById("synth-nodes").style.display = "flex", document.getElementById("drum-nodes").style.display = "none")
  }), document.getElementById("show-drums").addEventListener("change", function () {
    this.checked && (o.activeNodes = document.getElementById("drum-nodes"), document.getElementById("drum-nodes").style.display = "flex", document.getElementById("synth-nodes").style.display = "none")
  }), o.bpmInput.value = o.bpm, o.bpmInput.addEventListener("change", function () {
    isNaN(this.value) || (o.bpm = Math.max(1, Math.min(300, this.value)), o.tickInterval = 60 / o.bpm / o.noteDivision), this.value = o.bpm
  }), forEach(o.synthSequencerNodes, function (e, t) {
    e.children[1].value = o.notes[t], e.children[0].checked = o.notesActive[t], e.addEventListener("mousedown", function (e) {
      o.holdingNode = this, o.nodeStart = this.children[1].value, o.nodeIndex = this.getAttribute("data-index"), o.noteChanged = !1, e && (o.startX = e.clientX, o.startY = e.clientY)
    })
  }), forEach(o.synthDrumNodes, function (t, e) {
    var a = t.parentNode.getAttribute("data-index"),
      n = t.getAttribute("data-drum");
    t.children[0].checked = 1 == o.drums[n][a], t.addEventListener("click", function (e) {
      t.children[0].checked = !t.children[0].checked, o.drums[n][a] = t.children[0].checked ? 1 : 0
    })
  })
}

function initKnob(e, t) {
  var a = e.getElementsByTagName("input")[0],
    n = e.children[0],
    o = Number(a.getAttribute("data-min")),
    i = (Number(a.getAttribute("data-max")) - o) / 200,
    s = getParam(a.getAttribute("data-param"), t);
  a.value = String(s).substring(0, 5), n.style.transform = "rotate(" + ((s - o) / i * 1.5 - 150) + "deg)"
}

function updateParam(e, t, a) {
  for (var n = e.split("."), o = 0, i = n.length, s = a; s && o < i;) o == i - 1 ? s[n[o]] = t : s = s[n[o]], o++
}

function getParam(e, t) {
  for (var a = e.split("."), n = 0, o = a.length, i = t; i && n < o;) {
    if (n == o - 1) return i[a[n]];
    i = i[a[n]], n++
  }
}

function toggleSequencerPlaying(e) {
  e.sequencerPlaying = !e.sequencerPlaying, e.sequencerPlaying ? (e.nextTick = e.context.currentTime, e.noteIndex = 15, e.started || (e.osc1.start(), e.osc2.start(), e.started = !0), runSequencer(e), e.playButton.innerHTML = "Stop") : (e.playButton.innerHTML = "Play", e.amp.gain.cancelScheduledValues(e.context.currentTime), e.amp.gain.linearRampToValueAtTime(1e-5, e.context.currentTime + .1), showActiveNode(e))
}

function showActiveNode(a) {
  a.sequencerPlaying ? forEach(a.activeNodes.children, function (e, t) {
    boolClass(e, "is-playing", a.noteIndex == t)
  }) : forEach(a.activeNodes.children, function (e, t) {
    boolClass(e, "is-playing", !1)
  })
}

function synthSave(e) {
  e.osc1Type = e.osc1.type, e.osc2Type = e.osc2.type;
  var t = JSON.stringify(e);
  window.localStorage.setItem("synth", t)
}
color.khaki = "#B4B17C", color.yellow = "#F4ECA4", color.red = "#B65B7F", color.green = "#5B8B6C", color.purple = "#7F519D", color.grey = "#E0DED1", color.black = "#1F0539", color.white = "#F5F4F0";
var synthLoadParams = ["ampEnv", "bpm", "tickInterval", "delayFeedbackInput", "delayTimeInput", "distortionInput", "drums", "grooveAmount", "grooveTime", "highpassEnv", "highpassFreq", "highpassFreqInput", "highpassResInput", "lowpassEnv", "lowpassFreq", "lowpassFreqInput", "lowpassResInput", "noteLength", "notes", "notesActive", "osc1Fine", "osc1Octave", "osc1Pitch", "osc1Semi", "osc1LevelInput", "osc2Fine", "osc2Octave", "osc2Pitch", "osc2Semi", "osc2LevelInput", "oscLevelInput", "oscPitch", "portamento", "portamentoInput", "reverbInput", "voltEnv"];

function synthLoad(t) {
  var a = window.localStorage.getItem("synth");
  a && (a = JSON.parse(a), forEach(synthLoadParams, function (e) {
    a[e] && (t[e] = a[e])
  }), t.osc1.type = a.osc1Type, t.osc2.type = a.osc2Type)
}

function calculateWaveform(e) {
  e.analyser.getByteTimeDomainData(e.dataArray)
}

function drawWaveform(e) {
  e.ctx.strokeStyle = color.white, e.ctx.lineJoin = "round", e.ctx.lineWidth = 2 / e.dpi, e.ctx.clearRect(0, 0, e.cw, e.ch), e.ctx.beginPath();
  for (var t = e.cw / e.bufferLength, a = 0, n = 0; n < e.bufferLength; n++) {
    var o = e.dataArray[n] / 128 * e.ch / 2;
    0 === n ? e.ctx.moveTo(a, o) : e.ctx.lineTo(a, o), a += t
  }
  e.ctx.stroke()
}
var typeInput, typeList, noteLetters = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"],
  sharpLetters = ["C#", "D#", "F#", "G#", "A#"],
  noteValues = {
    C0: 16.35,
    "C#0": 17.32,
    Db0: 17.32,
    D0: 18.35,
    "D#0": 19.45,
    Eb0: 19.45,
    E0: 20.6,
    F0: 21.83,
    "F#0": 23.12,
    Gb0: 23.12,
    G0: 24.5,
    "G#0": 25.96,
    Ab0: 25.96,
    A0: 27.5,
    "A#0": 29.14,
    Bb0: 29.14,
    B0: 30.87,
    C1: 32.7,
    "C#1": 34.65,
    Db1: 34.65,
    D1: 36.71,
    "D#1": 38.89,
    Eb1: 38.89,
    E1: 41.2,
    F1: 43.65,
    "F#1": 46.25,
    Gb1: 46.25,
    G1: 49,
    "G#1": 51.91,
    Ab1: 51.91,
    A1: 55,
    "A#1": 58.27,
    Bb1: 58.27,
    B1: 61.74,
    C2: 65.41,
    "C#2": 69.3,
    Db2: 69.3,
    D2: 73.42,
    "D#2": 77.78,
    Eb2: 77.78,
    E2: 82.41,
    F2: 87.31,
    "F#2": 92.5,
    Gb2: 92.5,
    G2: 98,
    "G#2": 103.83,
    Ab2: 103.83,
    A2: 110,
    "A#2": 116.54,
    Bb2: 116.54,
    B2: 123.47,
    C3: 130.81,
    "C#3": 138.59,
    Db3: 138.59,
    D3: 146.83,
    "D#3": 155.56,
    Eb3: 155.56,
    E3: 164.81,
    F3: 174.61,
    "F#3": 185,
    Gb3: 185,
    G3: 196,
    "G#3": 207.65,
    Ab3: 207.65,
    A3: 220,
    "A#3": 233.08,
    Bb3: 233.08,
    B3: 246.94,
    C4: 261.63,
    "C#4": 277.18,
    Db4: 277.18,
    D4: 293.66,
    "D#4": 311.13,
    Eb4: 311.13,
    E4: 329.63,
    F4: 349.23,
    "F#4": 369.99,
    Gb4: 369.99,
    G4: 392,
    "G#4": 415.3,
    Ab4: 415.3,
    A4: 440,
    "A#4": 466.16,
    Bb4: 466.16,
    B4: 493.88,
    C5: 523.25,
    "C#5": 554.37,
    Db5: 554.37,
    D5: 587.33,
    "D#5": 622.25,
    Eb5: 622.25,
    E5: 659.26,
    F5: 698.46,
    "F#5": 739.99,
    Gb5: 739.99,
    G5: 783.99,
    "G#5": 830.61,
    Ab5: 830.61,
    A5: 880,
    "A#5": 932.33,
    Bb5: 932.33,
    B5: 987.77,
    C6: 1046.5,
    "C#6": 1108.73,
    Db6: 1108.73,
    D6: 1174.66,
    "D#6": 1244.51,
    Eb6: 1244.51,
    E6: 1318.51,
    F6: 1396.91,
    "F#6": 1479.98,
    Gb6: 1479.98,
    G6: 1567.98,
    "G#6": 1661.22,
    Ab6: 1661.22,
    A6: 1760,
    "A#6": 1864.66,
    Bb6: 1864.66,
    B6: 1975.53,
    C7: 2093,
    "C#7": 2217.46,
    Db7: 2217.46,
    D7: 2349.32,
    "D#7": 2489.02,
    Eb7: 2489.02,
    E7: 2637.02,
    F7: 2793.83,
    "F#7": 2959.96,
    Gb7: 2959.96,
    G7: 3135.96,
    "G#7": 3322.44,
    Ab7: 3322.44,
    A7: 3520,
    "A#7": 3729.31,
    Bb7: 3729.31,
    B7: 3951.07,
    C8: 4186.01
  };

function tileInitTEMPLATE(e) {
  e.data = {}
}

function tileUpdateTEMPLATE(e, t, a) {}

function tileDrawTEMPLATE(e, t) {}

function tileInitTictac(t) {
  t.data = {
    board: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
    pieces: t.el.getElementsByClassName("tictac__input"),
    finished: !1,
    moves: 0,
    drawQueue: [],
    wobble: 0,
    curve: 0,
    speed: .015,
    line: 0,
    ln: color.white,
    grad: [["white", 1, .8], ["black", 15.3, 1], ["white", 15.4, 1], ["white", 14.44, .8], ["black", 36.9, 1], ["white", 36.9, 1], ["white", 31.64, .8], ["black", 58.4, 1], ["white", 58.4, 1], ["white", 62.5, .8], ["black", 76.4, 1], ["white", 64.58, 1]],
    bg: t.el.getElementsByClassName("tictac__bg")[0],
    bgInner: t.el.getElementsByClassName("tictac__bgInner")[0],
    white: !1,
    sharp: !1,
    gs: .15
  }, setTimeout(function () {
    t.data.drawQueue.push(["board", 0, 0, 0, Math.random()])
  }, 1e3), initCanvasAndAppend(document.getElementById("tictac-canvas"), t), tileResizeTictac.bind(t)(), resizeQueue.push(tileResizeTictac.bind(t)), forEach(t.data.pieces, function (e) {
    e.addEventListener("click", function (e) {
      ticTacClick(e.target, t)
    })
  })
}

function tileResizeTictac() {
  this.data.ctx.lineWidth = 4 * this.data.dpi / 2, this.data.ctx.strokeStyle = this.data.ln, this.data.cl = 0 * this.data.cw, this.data.cr = 1 * this.data.cw, this.data.ct = 0 * this.data.ch, this.data.cb = 1 * this.data.ch
}

function tileUpdateTictac(e, a, t) {
  e.isActive && (updateTileMouseRelative(e, 60, t), a.grad.forEach(function (e, t) {
    1 == t && e[1] > (a.sharp ? 2 : 20) && (a.grad.unshift([a.white ? "black" : "white", 0, 1]), a.sharp && a.grad.unshift([a.white ? "white" : "black", 1, .8]), a.white = !a.white, a.sharp = !a.sharp), 0 < t && (e[1] += e[2] * a.gs), 100 < e[1] && a.grad.splice(t, 1)
  }), e.drawRequired = !0)
}

function drawTicTacGrad(e, a) {
  var n = "";
  forEach(a.grad, function (e, t) {
    n += color[e[0]] + " " + e[1] + "%", t < a.grad.length - 1 && (n += ", ")
  }), a.bgInner.style.background = "radial-gradient(" + n + ")";
  var t = e.mouse.x - Math.abs(e.mouse.y / 2);
  a.bgInner.style.transform = "translateX(" + 5 * t + "%) scale(" + (1 - t / 2) + ")"
}

function tileDrawTictac(e, v) {
  drawTicTacGrad(e, v), v.drawQueue.forEach(function (e, t) {
    if (1 <= e[3]) v.drawQueue.splice(t, 1);
    else {
      var a = e[3],
        n = (.015 + Math.random() / 200 - Math.abs((a - .5) / 35)) * v.speed;
      n = v.speed;
      var o = e[4],
        i = (Math.random() - .5) * v.curve * n * 100;
      switch (v.ctx.globalAlpha = 1, e[0]) {
        case "board":
          if (n *= .75, a < .25) var s = v.cl + 4 * a * v.cw + 10 * (Math.random() - 1),
            r = v.cl + 4 * a * v.cw + 4 * n * v.cw + 10 * Math.random(),
            l = v.ct + v.ch / 3 + (Math.random() - .5) * v.wobble * n * 50 + o,
            c = v.ct + v.ch / 3 + (Math.random() - .5) * v.wobble * n * 50 + o + i;
          else if (a < .5) s = v.cl + 4 * (a - .25) * v.cw + 10 * (Math.random() - 1), r = v.cl + 4 * (a - .25) * v.cw + 4 * n * v.cw + 10 * Math.random(), l = v.ct + 2 * v.ch / 3 + (Math.random() - .5) * v.wobble * n * 50 + o, c = v.ct + 2 * v.ch / 3 + (Math.random() - .5) * v.wobble * n * 50 + o + i;
          else if (a < .75) s = v.cl + v.cw / 3 + (Math.random() - .5) * v.wobble * n * 50 + o, r = v.cl + v.cw / 3 + (Math.random() - .5) * v.wobble * n * 50 + o + i, l = v.ct + 4 * (a - .5) * v.ch + 10 * (Math.random() - 1), c = v.ct + 4 * (a - .5) * v.ch + 4 * n * v.ch + 10 * (Math.random() + 1);
          else s = v.cl + 2 * v.cw / 3 + (Math.random() - .5) * v.wobble * n * 50 + o, r = v.cl + 2 * v.cw / 3 + (Math.random() - .5) * v.wobble * n * 50 + o + i, l = v.ct + 4 * (a - .75) * v.ch + 10 * (Math.random() - 1), c = v.ct + 4 * (a - .75) * v.ch + 4 * n * v.ch + 10 * (Math.random() + 1);
          v.ctx.beginPath(), v.ctx.moveTo(s, l), v.ctx.lineTo(r, c), o += i, o *= .98;
          break;
        case "tic":
          n *= 2;
          var d = e[5],
            u = v.cl + (e[2] + .5) / 3 * v.cw + (Math.random() - .5) * v.wobble * n * 10 + o / 1.5,
            p = v.ct + (e[1] + .5) / 3 * v.ch + (Math.random() - .5) * v.wobble * n * 10 + o / 1.5;
          v.ctx.beginPath(), v.ctx.arc(u, p, Math.max(1, v.cw / 9 + o / 2), 3.5 * (a + 1 - Math.random() / 20 + d) * Math.PI, 3.55 * (a + n + 1 + Math.random() / 20 + d) * Math.PI), o += i;
          break;
        case "tac":
          n *= 2;
          u = v.cl + (e[2] + .5) / 3 * v.cw, p = v.ct + (e[1] + .5) / 3 * v.ch;
          if (a < .5) s = u - v.cw / 9 + 2 * a * v.cw / 4.5 + (Math.random() - 2) * v.wobble * n * 10 + o - 2, r = u - v.cw / 9 + 2 * (a + n) * v.cw / 4.5 + Math.random() * v.wobble * n * 10 + o + i + 2, l = p - v.ch / 9 + 2 * a * v.ch / 4.5 + (Math.random() - 2) * v.wobble * n * 10 - o - 2, c = p - v.ch / 9 + 2 * (a + n) * v.ch / 4.5 + Math.random() * v.wobble * n * 10 - o - i + 2;
          else s = u + v.cw / 9 - 2 * (a - .5) * v.cw / 4.5 + Math.random() * v.wobble * n * 10 + o + 2, r = u + v.cw / 9 - 2 * (a - .5 + n) * v.cw / 4.5 + (Math.random() - 2) * v.wobble * n * 10 + o + i - 2, l = p - v.ch / 9 + 2 * (a - .5) * v.ch / 4.5 + (Math.random() - 2) * v.wobble * n * 10 + o - 2, c = p - v.ch / 9 + 2 * (a - .5 + n) * v.ch / 4.5 + Math.random() * v.wobble * n * 10 + o + i + 2;
          v.ctx.beginPath(), v.ctx.moveTo(s, l), v.ctx.lineTo(r, c), o += i, o *= .98;
          break;
        case "win":
          n *= 2;
          var h = e[2][1] - e[1][1],
            m = e[2][0] - e[1][0];
          u = e[1][1] + h / 2, p = e[1][0] + m / 2;
          h *= 1.45, m *= 1.45;
          s = v.cl + (.5 + u + (a - .5) * h) / 3 * v.cw + (Math.random() - 1) * v.wobble + o, r = v.cl + (.5 + u + (a + n - .5) * h) / 3 * v.cw + Math.random() * v.wobble + o + i, l = v.ct + (.5 + p + (a - .5) * m) / 3 * v.ch + (Math.random() - 1) * v.wobble + o, c = v.ct + (.5 + p + (a + n - .5) * m) / 3 * v.ch + Math.random() * v.wobble + o + i;
          v.ctx.beginPath(), v.ctx.moveTo(s, l), v.ctx.lineTo(r, c), o += i, o *= .98
      }
      v.ctx.stroke(), e[4] = o, e[3] += n
    }
  })
}

function ticTacClick(e, t) {
  if (t.data.finished) ticTacReset(t);
  else {
    var a = parseFloat(e.getAttribute("data-tr")),
      n = parseFloat(e.getAttribute("data-tc"));
    0 == t.data.board[a][n] && (t.data.board[a][n] = 1, addClass(e, "is-tic"), t.data.drawQueue.push(["tic", a, n, 0, 2 * Math.random(), 2 * Math.random()]), t.data.moves++, ticTacCheckWin(t), ticTacComputerMove(t))
  }
}

function ticTacCheckWin(e) {
  var t = e.data.board;
  t[0][0] == t[0][1] && t[0][1] == t[0][2] && t[0][2] == t[0][0] && 0 != t[0][0] && ticTacApplyWin(e, [0, 0], [0, 2]), t[1][0] == t[1][1] && t[1][1] == t[1][2] && t[1][2] == t[1][0] && 0 != t[1][0] && ticTacApplyWin(e, [1, 0], [1, 2]), t[2][0] == t[2][1] && t[2][1] == t[2][2] && t[2][2] == t[2][0] && 0 != t[2][0] && ticTacApplyWin(e, [2, 0], [2, 2]), t[0][0] == t[1][0] && t[1][0] == t[2][0] && t[2][0] == t[0][0] && 0 != t[0][0] && ticTacApplyWin(e, [0, 0], [2, 0]), t[0][1] == t[1][1] && t[1][1] == t[2][1] && t[2][1] == t[0][1] && 0 != t[0][1] && ticTacApplyWin(e, [0, 1], [2, 1]), t[0][2] == t[1][2] && t[1][2] == t[2][2] && t[2][2] == t[0][2] && 0 != t[0][2] && ticTacApplyWin(e, [0, 2], [2, 2]), t[0][0] == t[1][1] && t[1][1] == t[2][2] && t[2][2] == t[0][0] && 0 != t[1][1] && ticTacApplyWin(e, [0, 0], [2, 2]), t[2][0] == t[1][1] && t[1][1] == t[0][2] && t[0][2] == t[2][0] && 0 != t[1][1] && ticTacApplyWin(e, [2, 0], [0, 2]), 9 <= e.data.moves && (e.data.finished = !0)
}

function ticTacApplyWin(e, t, a) {
  e.data.finished = !0, e.data.drawQueue.push(["win", t, a, 0, Math.random()])
}

function ticTacComputerMove(e) {
  if (!e.data.finished) {
    for (var t = !1; !t;) {
      var a = Math.floor(3 * Math.random()),
        n = Math.floor(3 * Math.random());
      0 == e.data.board[a][n] && (e.data.board[a][n] = -1, e.data.drawQueue.push(["tac", a, n, 0, Math.random()]), addClass(e.data.pieces[3 * a + n], "is-tac"), t = !0)
    }
    e.data.moves++, ticTacCheckWin(e)
  }
}

function ticTacReset(e) {
  for (forEach(e.data.pieces, function (e) {
      removeClass(e, "is-tic"), removeClass(e, "is-tac")
    }), e.data.curve++, e.data.board = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], e.data.finished = !1, e.data.moves = 0, e.data.drawQueue = [], e.data.ctx.clearRect(0, 0, 1.5 * e.data.cw, 1.5 * e.data.ch); e.data.bg == e.data.ln;) e.data.ln = e.data.colors[Math.floor(Math.random() * e.data.colors.length)];
  e.data.ctx.strokeStyle = e.data.ln, e.data.ctx.fillStyle = e.data.bg, e.data.ctx.globalAlpha = 1, e.data.drawQueue.push(["board", 0, 0, 0, Math.random()])
}
var typeWaiting = !1;

function tileInitType(t) {
  t = t;
  typeInput = document.getElementById("type-input"), typeList = document.getElementById("type-list"), typeInput.addEventListener("keydown", function (e) {
    13 == e.keyCode && sendMessage(this.value, t)
  }), typeInput.addEventListener("blur", function (e) {
    sendMessage(this.value, t)
  }), typeList.addEventListener("click", function (e) {
    typeInput.focus()
  }), t.data.sessionId = null
}

function sendMessage(e, t) {
  if (!typeWaiting && e && 0 < e.length) {
    typeInput.value = "";
    var a = document.createElement("span");
    addClass(a, "type__response"), addClass(a, "type__response--us"), a.innerHTML = e, typeList.prepend(a), setTimeout(function () {
      getResponse(e, t)
    }, 300)
  }
}

function getResponse(o, i) {
  typeWaiting = !0, addClass(typeInput, "type__input--waiting"), postAjax(i.data.sessionId ? "/chat/message.php" : "/chat/init.php", {
    q: o,
    sessionid: i.data.sessionId
  }, function (e) {
    var t = JSON.parse(e);
    if (t) {
      i.data.sessionId || (i.data.sessionId = t.sessionid);
      var a = document.createElement("span");
      addClass(a, "type__response"), addClass(a, "type__response--them");
      var n = t.response || t.error || o;
      a.innerHTML = n, typeList.prepend(a), typeWaiting = !1, removeClass(typeInput, "type__input--waiting")
    }
  })
}

function tileInitWave(e) {
  var t = document.getElementById("wave-canvas");
  e.data = {
    waveCount: 200,
    waves: [],
    noise: new SimplexNoise,
    move: 7,
    t: Date.now(),
    tSpeed: 2e4,
    indexSpread: 120,
    ySpread: 1e3,
    mouseAmount: 6,
    burstAmount: 4,
    burst: 1
  }, initCanvasAndAppend(t, e);
  for (var a = 1; a < e.data.waveCount; a++) e.data.waves.push(new Wave(a, a / e.data.waveCount * (1.5 * e.data.ch) - e.data.ch / 4, e.data));
  resizeQueue.push(tileResizeWave.bind(e))
}

function tileResizeWave() {
  var t = this.resizeRatio;
  forEach(this.data.waves, function (e) {
    e.y0 *= t, e.y1 *= t, e.y2 *= t
  })
}

function Wave(e, t, a) {
  this.index = e, this.y0 = t, this.y1 = t, this.y2 = t, this.cp1 = [a.cw / 2, t], this.cp2 = [a.cw / 2, t]
}

function tileUpdateWave(e, a, n) {
  if (e.isActive || e.isFirstFrame) {
    a.t = Date.now(), updateTileMouseRelative(e, 1);
    for (var o = 0; o < a.waveCount - 1; o++) {
      var i = a.noise.noise3D(t / a.tSpeed, a.waves[o].index / a.indexSpread, a.waves[o].y1 / a.ySpread) * a.move,
        s = a.noise.noise3D(-t / a.tSpeed, a.waves[o].index / a.indexSpread, a.waves[o].y2 / a.ySpread) * a.move;
      s += e.mouse.y * e.mouse.x * a.mouseAmount * a.burst, i += e.mouse.y * (.5 - e.mouse.x) * a.mouseAmount * a.burst, mouse.down ? a.burst += (a.burstAmount - a.burst) / 5 : a.burst += (1 - a.burst) / 5, a.waves[o].y1 += (a.waves[o].y0 - a.waves[o].y1) / 100, a.waves[o].y2 += (a.waves[o].y0 - a.waves[o].y2) / 100, a.waves[o].y1 += i, a.waves[o].y2 += s;
      var r = Math.abs(a.waves[o].y1 - a.waves[o].y2) / a.ch * 2;
      this.cp1 = [a.cw * (.5 - r), a.waves[o].y0], this.cp2 = [a.cw * (.5 + r), a.waves[o].y0]
    }
    e.drawRequired = !0
  }
}

function tileDrawWave(e, t) {
  t.ctx.lineWidth = .01 * t.cw, t.ctx.strokeStyle = color.green, t.ctx.clearRect(0, 0, t.cw, t.ch);
  for (var a = 0; a < t.waveCount - 1; a++) {
    var n = t.waves[a];
    t.ctx.beginPath(), t.ctx.moveTo(0, n.y1), t.ctx.bezierCurveTo(n.cp1[0], n.cp1[1], n.cp2[0], n.cp2[1], t.cw, n.y2), t.ctx.stroke()
  }
}

function tileInitYume(t) {
  t.data = {
    pieces: [],
    mousePush: 5,
    homePull: .02,
    diss: .9
  }, forEach(document.getElementById("parts").children, function (e) {
    t.data.pieces.push(new Piece(e, t))
  })
}

function Piece(e, t) {
  var a = (this.el = e).getBoundingClientRect();
  this.pos = {
    x: a.left - t.left + a.width / 2,
    y: a.top - t.top + scrollTop + a.height / 2
  }, this.offset = {
    x: 0,
    y: 0
  }, this.final = {
    x: this.pos.x,
    y: this.pos.y
  }, this.vel = {
    x: 0,
    y: 0
  }, this.hyp = .7 * getVectorDist(0, 0, a.width, a.height)
}

function tileUpdateYume(o, i, e) {
  if (o.isActive) {
    updateTileMousePixels(o, 2, e);
    var s = o.bounds.width / 6;
    forEach(o.data.pieces, function (e, t) {
      var a = getVectorDist(e.final.x, e.final.y, o.mouse.x, o.mouse.y) - e.hyp,
        n = Math.pow(Math.max(0, s - a) / s, 1.5);
      e.offset.x += (Math.random() - .5) * (mouse.down ? 100 : 20) * n, e.offset.y += (Math.random() - .5) * (mouse.down ? 100 : 20) * n, e.offset.x *= i.diss, e.offset.y *= i.diss, e.final.x = e.pos.x + e.offset.x, e.final.y = e.pos.y + e.offset.y
    }), o.drawRequired = !0
  }
}

function tileDrawYume(e, t) {
  forEach(e.data.pieces, function (e) {
    e.el.setAttribute("transform", "translate(" + e.offset.x + " " + e.offset.y + ")")
  })
}

function tileInitZa(e) {
  var t = document.getElementById("za-canvas"),
    a = [["za", "ザ"], ["n", "ン"], ["ko", "コ"], ["ku", "ク"], ["na", "ナ"], ["te", "テ"], ["n", "ン"], ["shi", "シ"], ["no", "ノ"], ["yo", "ヨ"], ["u", "ウ"], ["ni", "ニ"], ["sh", "シ"], ["yo", "ョ"], ["u", "ウ"], ["ne", "ネ"], ["n", "ン"], ["yo", "ヨ"], ["shi", "シ"], ["n", "ン"], ["wa", "ワ"], ["ni", "ニ"], ["na", "ナ"], ["re", "レ"]];
  e.data = {
    message: a,
    messageLength: a.length,
    messageIndex: 0,
    engEl: document.getElementById("za-eng"),
    jpEl: document.getElementById("za-jp"),
    offsetDist: 60,
    offsetAngle: 40,
    i: 0,
    particles: [],
    pCount: 1200,
    pSpeed: .001,
    pVar: .01,
    pDiss: .99,
    noise: new SimplexNoise
  }, e.el.addEventListener("click", function () {
    nextLetter(e)
  }), initCanvasAndAppend(t, e)
}

function tileUpdateZa(e, n, a) {
  if (e.isFirstFrame && (e.mouse.x = 0, e.mouse.y = 0), e.isActive && (updateTileMouseRelative(e, 40, a), e.diff = getVectorDist(0, 0, e.mouse.x, e.mouse.y)), (.01 < Math.abs(e.diff) || e.isActive) && (e.mouse.x += (Math.random() - .5) / 2e3, e.mouse.y += (Math.random() - .5) / 2e3, e.mouse.x *= .9, e.mouse.y *= .9, e.drawRequired = !0), 0 < n.particles.length) {
    var o = a / 16;
    n.particles.forEach(function (e, a) {
      e.rad -= .001 * o, e.rad *= 1 - (1 - .975) * o, e.angle += 10 * n.noise.noise3D(2 * e.x, 2 * e.y, t / 3e3) * o, e.angle += (e.dir - e.angle) / 15 * o, e.xv = Math.cos(e.angle / 180 * Math.PI) * e.vel, e.yv = Math.sin(e.angle / 180 * Math.PI) * e.vel, e.vel *= 1 - (1 - n.pDiss) * o, e.x += e.xv * o, e.y += e.yv * o, (1 < e.x || e.x < 0 || 1 < e.y || e.y < 0 || e.rad <= .1) && n.particles.splice(a, 1)
    }), e.drawRequired = !0
  }
}

function tileDrawZa(e, t) {
  if (t.ctx.fillStyle = color.grey, t.i++, .002 < Math.abs(e.mouse.x) || .002 < Math.abs(e.mouse.y) || t.i % 100 == 0) {
    t.i = 0;
    var a = "translate3d(" + e.mouse.x * t.offsetDist * rem + "rem, " + e.mouse.y * t.offsetDist * rem + "rem, 10rem)",
      n = "rotateY(" + e.mouse.x * t.offsetAngle + "deg) rotateX(" + e.mouse.y * -t.offsetAngle + "deg)";
    t.jpEl.style.transform = n + " " + a
  }
  0 < t.particles.length && (t.ctx.clearRect(0, 0, t.cw, t.ch), t.particles.forEach(function (e) {
    t.ctx.fillRect(e.x * t.cw, e.y * t.ch, e.rad, e.rad)
  }))
}

function nextLetter(e) {
  e.data.messageIndex++, e.data.messageIndex >= e.data.messageLength && (e.data.messageIndex = 0), e.data.engEl.innerHTML = e.data.message[e.data.messageIndex][0], e.data.jpEl.innerHTML = e.data.message[e.data.messageIndex][1], addZaParticles(e)
}

function addZaParticles(e) {
  for (var t = 0; t < e.data.pCount; t++) e.data.particles.push(new Particle(.5, .5, e.data.dpi * (1 + 3.5 * Math.random()), e.data.pSpeed + Math.random() * e.data.pVar, 360 * Math.random()))
}

function Particle(e, t, a, n, o) {
  this.x = e + .3 * Math.cos(o / 180 * Math.PI), this.y = t + .3 * Math.sin(o / 180 * Math.PI), this.rad = a, this.vel = n, this.angle = o, this.dir = o, this.xv = 0, this.yv = 0
}
